<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anti-Gravity Run - 反重力ラン</title>
    <!--
    AI Model: Gemini 2.0 Flash
    User Prompt: このディレクトリにすでにあるWebアプリケーションの考え方を踏まえて、新しいディレクトリを作り「反重力」をテーマとしたゲームを作ってください。
    AI Approach: HTML5 Canvas used for high-performance rendering. Implemented a custom physics engine where the gravity vector can be inverted by user input. Single-file architecture with no external dependencies.
    Implementation Intent: To create an engaging, fast-paced action game that intuitively demonstrates the concept of "anti-gravity" through simple one-tap controls.
    -->
    <style>
        :root {
            --bg-color: #0f0f1a;
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff00;
            --text-color: #ffffff;
        }
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none; /* Prevent zoom/scroll on mobile */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
        }
        canvas {
            display: block;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #score-display {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px var(--neon-blue);
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(15, 15, 26, 0.9);
            padding: 40px;
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            pointer-events: auto;
            box-shadow: 0 0 15px var(--neon-blue);
        }
        h1 {
            margin: 0 0 20px 0;
            font-size: 3em;
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        p {
            font-size: 1.2em;
            margin-bottom: 30px;
            line-height: 1.5;
        }
        button {
            background: transparent;
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            padding: 15px 40px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover {
            background: var(--neon-blue);
            color: var(--bg-color);
            box-shadow: 0 0 20px var(--neon-blue);
        }
        .hidden {
            display: none !important;
        }
        .controls-hint {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="score-display">SCORE: 0</div>
    </div>
    
    <div id="start-screen">
        <h1>Anti-Gravity<br>Run</h1>
        <p>重力を操り、障害物を避けろ！</p>
        <button id="start-btn">START</button>
        <div class="controls-hint">Click / Space / Tap to Flip Gravity</div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>GAME OVER</h1>
        <p>SCORE: <span id="final-score">0</span></p>
        <button id="restart-btn">RETRY</button>
    </div>
</div>

<script>
    // Game Constants
    const GRAVITY_FORCE = 0.6;
    const JUMP_FORCE = 0; // Not a jump, but a gravity flip
    const SPEED_INITIAL = 5;
    const SPEED_INCREMENT = 0.001;
    const OBSTACLE_SPAWN_RATE = 90; // Frames
    const PARTICLE_COUNT = 20;

    // Game State
    let canvas, ctx;
    let width, height;
    let gameLoopId;
    let isPlaying = false;
    let score = 0;
    let speed = SPEED_INITIAL;
    let frameCount = 0;
    
    // Entities
    let player;
    let obstacles = [];
    let particles = [];
    let bgStars = [];

    // Audio Context
    let audioCtx;

    class Player {
        constructor() {
            this.size = 30;
            this.x = width * 0.2;
            this.y = height / 2;
            this.vy = 0;
            this.gravityDir = 1; // 1 for down, -1 for up
            this.color = '#00f3ff';
            this.isGrounded = false;
            this.rotation = 0;
        }

        update() {
            // Apply gravity
            this.vy += GRAVITY_FORCE * this.gravityDir;
            this.y += this.vy;

            // Floor/Ceiling collision
            if (this.y + this.size / 2 > height) {
                this.y = height - this.size / 2;
                this.vy = 0;
                this.isGrounded = true;
                if (this.gravityDir === 1) this.createLandingParticles();
            } else if (this.y - this.size / 2 < 0) {
                this.y = this.size / 2;
                this.vy = 0;
                this.isGrounded = true;
                if (this.gravityDir === -1) this.createLandingParticles();
            } else {
                this.isGrounded = false;
            }

            // Rotation effect
            this.rotation += 0.1 * speed;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // Neon glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
            
            // Draw player shape (Square with inner detail)
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(-this.size/4, -this.size/4, this.size/2, this.size/2);
            
            ctx.restore();
            
            // Trail effect
            if (frameCount % 3 === 0) {
                particles.push(new Particle(this.x, this.y, this.color, 0, 0, 10, 0.1));
            }
        }

        flipGravity() {
            this.gravityDir *= -1;
            this.createLandingParticles();
            playSound('flip');
        }

        createLandingParticles() {
            for (let i = 0; i < 5; i++) {
                particles.push(new Particle(
                    this.x, 
                    this.y + (this.size/2 * this.gravityDir), 
                    '#ffffff', 
                    (Math.random() - 0.5) * 5, 
                    (Math.random() - 0.5) * 2, 
                    5, 
                    0.05
                ));
            }
        }
    }

    class Obstacle {
        constructor() {
            this.w = 40;
            this.h = 60 + Math.random() * 60;
            this.x = width;
            // Randomly spawn on floor or ceiling
            this.isOnFloor = Math.random() > 0.5;
            this.y = this.isOnFloor ? height - this.h : 0;
            this.color = '#ff00ff';
            this.markedForDeletion = false;
        }

        update() {
            this.x -= speed;
            if (this.x + this.w < 0) {
                this.markedForDeletion = true;
                score++;
                document.getElementById('score-display').innerText = `SCORE: ${score}`;
            }
        }

        draw() {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            // Striped pattern
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            for(let i=0; i<this.h; i+=20) {
                ctx.fillRect(this.x, this.y + i, this.w, 5);
            }
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, vx, vy, size, shrink) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.vx = vx;
            this.vy = vy;
            this.size = size;
            this.shrink = shrink;
            this.life = 1.0;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.size -= this.shrink;
            this.life -= 0.02;
        }

        draw() {
            if (this.size <= 0 || this.life <= 0) return;
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Star {
        constructor() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.size = Math.random() * 2;
            this.speedRatio = Math.random() * 0.5 + 0.1;
        }
        update() {
            this.x -= speed * this.speedRatio;
            if (this.x < 0) this.x = width;
        }
        draw() {
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 0.5;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function init() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        resize();
        window.addEventListener('resize', resize);
        
        // Input handling
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                handleInput();
                e.preventDefault(); // Prevent scrolling
            }
        });
        window.addEventListener('touchstart', (e) => {
            handleInput();
            e.preventDefault();
        }, {passive: false});
        window.addEventListener('mousedown', handleInput);

        // UI Buttons
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

        // Init background stars
        for(let i=0; i<50; i++) {
            bgStars.push(new Star());
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        // Keep player in relative position if resizing
        if (player) {
            player.x = width * 0.2;
            if (player.y > height) player.y = height - player.size;
        }
    }

    function handleInput() {
        if (isPlaying && player) {
            player.flipGravity();
        }
    }

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        // Init Audio Context on user interaction
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }

        player = new Player();
        obstacles = [];
        particles = [];
        score = 0;
        speed = SPEED_INITIAL;
        frameCount = 0;
        isPlaying = true;
        document.getElementById('score-display').innerText = `SCORE: 0`;
        
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        gameLoop();
    }

    function gameOver() {
        isPlaying = false;
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-screen').classList.remove('hidden');
        playSound('gameover');
    }

    function gameLoop() {
        if (!isPlaying) return;

        ctx.clearRect(0, 0, width, height);

        // Update Background
        bgStars.forEach(star => {
            star.update();
            star.draw();
        });

        // Update Player
        player.update();
        player.draw();

        // Update Obstacles
        if (frameCount % Math.max(30, OBSTACLE_SPAWN_RATE - Math.floor(speed * 2)) === 0) {
            obstacles.push(new Obstacle());
        }

        obstacles.forEach((obs, index) => {
            obs.update();
            obs.draw();
            
            // Collision Detection
            if (checkCollision(player, obs)) {
                gameOver();
            }

            if (obs.markedForDeletion) {
                obstacles.splice(index, 1);
            }
        });

        // Update Particles
        particles.forEach((p, index) => {
            p.update();
            p.draw();
            if (p.size <= 0 || p.life <= 0) {
                particles.splice(index, 1);
            }
        });

        // Increase difficulty
        speed += SPEED_INCREMENT;
        frameCount++;

        gameLoopId = requestAnimationFrame(gameLoop);
    }

    function checkCollision(player, obs) {
        // Simple AABB collision
        // Player is centered, so we need to adjust coordinates
        const px = player.x - player.size/2;
        const py = player.y - player.size/2;
        const pw = player.size;
        const ph = player.size;

        return (
            px < obs.x + obs.w &&
            px + pw > obs.x &&
            py < obs.y + obs.h &&
            py + ph > obs.y
        );
    }

    // Simple Sound Synth
    function playSound(type) {
        if (!audioCtx) return;
        
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        if (type === 'flip') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'gameover') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }
    }

    // Initial draw
    init();

</script>
</body>
</html>

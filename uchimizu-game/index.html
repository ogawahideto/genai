<!--
AI Model: Claude 3.5 Sonnet
User Prompt: æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã‚’ä½œã‚Šã€æ‰“ã¡æ°´ã§ä¸–ç•Œã‚’å†·ã‚„ã™ã‚²ãƒ¼ãƒ ã‚’ä½œã£ã¦ãã ã•ã„
AI Approach: HTML5 Canvasã‚’ä½¿ç”¨ã—ãŸã‚¯ãƒªãƒƒã‚¯ãƒ™ãƒ¼ã‚¹ã®æ‰“ã¡æ°´ã‚²ãƒ¼ãƒ ã€‚æ¸©åº¦ã‚·ã‚¹ãƒ†ãƒ ã¨æ°´ã—ã¶ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…
Implementation Intent: æ—¥æœ¬ã®å¤ã®æ–‡åŒ–ã§ã‚ã‚‹æ‰“ã¡æ°´ã‚’ãƒ†ãƒ¼ãƒã«ã—ãŸæ¶¼ã—ã’ãªã‚²ãƒ¼ãƒ ä½“é¨“ã‚’æä¾›
-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰“ã¡æ°´ã§ä¸–ç•Œã‚’å†·ã‚„ã™ã‚²ãƒ¼ãƒ </title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #ff4444 0%, #ff8888 50%, #ffcccc 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            transition: background 0.5s ease;
        }

        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 10px 0;
            font-size: clamp(1.5rem, 4vw, 2rem);
        }

        canvas {
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            cursor: crosshair;
            max-width: 100%;
            height: auto;
        }

        .ui {
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            margin: 10px 0;
            font-size: 1.2rem;
            text-align: center;
        }

        .temperature-bar {
            width: min(300px, 80vw);
            height: 20px;
            background: linear-gradient(to right, #0066ff, #00ccff, #ffff00, #ff6600, #ff0000);
            border: 2px solid #333;
            border-radius: 10px;
            position: relative;
            margin: 10px 0;
        }

        .temperature-indicator {
            width: 4px;
            height: 24px;
            background: white;
            border: 1px solid #333;
            position: absolute;
            top: -2px;
            transition: left 0.3s ease;
        }

        .instructions {
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            margin: 10px;
            text-align: center;
            font-size: 1rem;
        }

        .emoticon-display {
            background: rgba(255, 255, 255, 0.9);
            border: 3px solid #333;
            border-radius: 15px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.5s ease;
        }

        .emoticon-face {
            font-size: 2.5rem;
            margin: 5px 0;
            transition: transform 0.3s ease;
        }

        .emoticon-face.bounce {
            animation: bounce 0.6s ease-in-out;
        }

        .emoticon-message {
            font-size: 1.1rem;
            color: #333;
            font-weight: bold;
            margin: 5px 0;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
    </style>
</head>
<body>
    <h1>ğŸŒŠ æ‰“ã¡æ°´ã§ä¸–ç•Œã‚’å†·ã‚„ãã† ğŸŒŠ</h1>
    
    <div class="ui">
        <div>ä¸–ç•Œã®æ¸©åº¦: <span id="temperature">35</span>Â°C</div>
        <div class="temperature-bar">
            <div class="temperature-indicator" id="tempIndicator"></div>
        </div>
        <div>ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
        <div>æ‰“ã¡æ°´å›æ•°: <span id="splashCount">0</span></div>
        <div>å¤šæ§˜æ€§ãƒœãƒ¼ãƒŠã‚¹: <span id="diversityBonus">0</span>%</div>
    </div>

    <div class="emoticon-display">
        <div class="emoticon-face" id="emoticonFace">(>_<)</div>
        <div class="emoticon-message" id="emoticonMessage">çŒ›æš‘ã ...</div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="instructions">
        ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ‰“ã¡æ°´ã‚’ã—ã¦ã€ä¸–ç•Œã‚’å†·ã‚„ãã†ï¼<br>
        ç›®æ¨™ï¼šæ¸©åº¦ã‚’20Â°Cä»¥ä¸‹ã«ã—ã‚ˆã†<br>
        <small>ğŸ’¡ é•ã†å ´æ‰€ã«æ‰“ã¡æ°´ã™ã‚‹ã»ã©åŠ¹æœãŒé«˜ããªã‚Šã¾ã™ï¼</small>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = {
            temperature: 35,
            score: 0,
            splashCount: 0,
            particles: [],
            heatSpots: [],
            gameWon: false,
            splashHistory: [],
            maxHistorySize: 5,
            diversityBonus: 0
        };

        // ç†±ã‚¹ãƒãƒƒãƒˆã‚’åˆæœŸåŒ–
        function initHeatSpots() {
            gameState.heatSpots = [];
            for (let i = 0; i < 8; i++) {
                gameState.heatSpots.push({
                    x: Math.random() * (canvas.width - 60) + 30,
                    y: Math.random() * (canvas.height - 60) + 30,
                    intensity: 0.5 + Math.random() * 0.5,
                    radius: 20 + Math.random() * 30,
                    cooled: false
                });
            }
        }

        // æ°´ã—ã¶ããƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¯ãƒ©ã‚¹
        class WaterParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.size = Math.random() * 6 + 2;
                this.alpha = 1;
                this.life = 60;
                this.maxLife = 60;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                this.alpha = this.life / this.maxLife;
                this.size *= 0.99;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = `rgba(64, 164, 255, ${this.alpha})`;
                ctx.shadowColor = 'rgba(64, 164, 255, 0.5)';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // æ¸©åº¦ã«å¿œã˜ãŸé¡”æ–‡å­—ã‚’å–å¾—ã™ã‚‹é–¢æ•°
        function getEmoticonByTemperature(temp) {
            if (temp >= 38) {
                return { face: "(;Â´Ğ”`)", message: "æš‘ã™ãã‚‹..." };
            } else if (temp >= 35) {
                return { face: "(>_<)", message: "çŒ›æš‘ã ..." };
            } else if (temp >= 32) {
                return { face: "(Â´ãƒ»Ï‰ãƒ»`)", message: "æš‘ã„ãªã" };
            } else if (temp >= 28) {
                return { face: "(-_-)", message: "ã¾ã æš‘ã„" };
            } else if (temp >= 25) {
                return { face: "(ãƒ»Ï‰ãƒ»)", message: "å°‘ã—æ¶¼ã—ã„" };
            } else if (temp >= 22) {
                return { face: "(Â´âˆ€`)", message: "ã„ã„æ„Ÿã˜ï¼" };
            } else if (temp >= 20) {
                return { face: "(^o^)", message: "æ¶¼ã—ã„ã€œâ™ª" };
            } else {
                return { face: "ãƒ½(Â´â–½`)/", message: "æœ€é«˜ã«æ¶¼ã—ã„ï¼" };
            }
        }

        // å¤šæ§˜æ€§ãƒœãƒ¼ãƒŠã‚¹ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
        function calculateDiversityBonus(x, y) {
            if (gameState.splashHistory.length === 0) {
                return 1.0; // æœ€åˆã®æ‰“ã¡æ°´ã¯é€šå¸¸åŠ¹æœ
            }

            let minDistance = Infinity;
            let totalDistance = 0;

            // éå»ã®æ‰“ã¡æ°´åœ°ç‚¹ã¨ã®è·é›¢ã‚’è¨ˆç®—
            gameState.splashHistory.forEach(splash => {
                const distance = Math.sqrt((x - splash.x) ** 2 + (y - splash.y) ** 2);
                minDistance = Math.min(minDistance, distance);
                totalDistance += distance;
            });

            // è¿‘ã™ãã‚‹å ´åˆã¯åŠ¹æœæ¸›å°‘ã€é ã„å ´åˆã¯åŠ¹æœå¢—åŠ 
            const avgDistance = totalDistance / gameState.splashHistory.length;
            
            let multiplier = 1.0;
            if (minDistance < 50) {
                // 50pxä»¥å†…ã«å‰å›ã®æ‰“ã¡æ°´ãŒã‚ã‚‹å ´åˆã¯åŠ¹æœæ¸›å°‘
                multiplier = 0.7 + (minDistance / 50) * 0.3;
            } else if (avgDistance > 150) {
                // å¹³å‡è·é›¢ãŒ150pxä»¥ä¸Šã®å ´åˆã¯è»½å¾®ãªãƒœãƒ¼ãƒŠã‚¹
                multiplier = Math.min(1.3, 1.0 + (avgDistance - 150) / 400);
            }

            return multiplier;
        }

        // æ‰“ã¡æ°´å±¥æ­´ã‚’æ›´æ–°
        function updateSplashHistory(x, y) {
            gameState.splashHistory.push({ x, y, timestamp: Date.now() });
            
            // å±¥æ­´ã‚µã‚¤ã‚ºã‚’åˆ¶é™
            if (gameState.splashHistory.length > gameState.maxHistorySize) {
                gameState.splashHistory.shift();
            }
        }

        // é¡”æ–‡å­—ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        let lastEmoticon = null;
        function updateEmoticon(temperature) {
            const emoticon = getEmoticonByTemperature(temperature);
            const faceElement = document.getElementById('emoticonFace');
            const messageElement = document.getElementById('emoticonMessage');
            
            // é¡”æ–‡å­—ãŒå¤‰ã‚ã£ãŸå ´åˆã®ã¿æ›´æ–°ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (!lastEmoticon || lastEmoticon.face !== emoticon.face) {
                faceElement.textContent = emoticon.face;
                messageElement.textContent = emoticon.message;
                
                // ãƒã‚¦ãƒ³ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                faceElement.classList.remove('bounce');
                setTimeout(() => {
                    faceElement.classList.add('bounce');
                }, 10);
                
                // èƒŒæ™¯è‰²ã‚’æ¸©åº¦ã«å¿œã˜ã¦å¤‰æ›´
                const emoticonDisplay = document.querySelector('.emoticon-display');
                if (temperature >= 35) {
                    emoticonDisplay.style.background = 'rgba(255, 200, 200, 0.9)';
                } else if (temperature >= 28) {
                    emoticonDisplay.style.background = 'rgba(255, 240, 200, 0.9)';
                } else if (temperature >= 22) {
                    emoticonDisplay.style.background = 'rgba(200, 255, 200, 0.9)';
                } else {
                    emoticonDisplay.style.background = 'rgba(200, 230, 255, 0.9)';
                }
                
                lastEmoticon = emoticon;
            }
        }

        // ã‚¯ãƒªãƒƒã‚¯ãƒ»ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
        function handleInteraction(event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (event.type === 'touchstart' || event.type === 'touchmove') {
                const touch = event.touches[0];
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                x = event.clientX - rect.left;
                y = event.clientY - rect.top;
            }
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è€ƒæ…®
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            x *= scaleX;
            y *= scaleY;
            
            // å¤šæ§˜æ€§ãƒœãƒ¼ãƒŠã‚¹ã‚’è¨ˆç®—
            const diversityMultiplier = calculateDiversityBonus(x, y);
            gameState.diversityBonus = Math.round((diversityMultiplier - 1) * 100);

            // æ°´ã—ã¶ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆï¼ˆåŠ¹æœã«å¿œã˜ã¦æ•°ã‚’èª¿æ•´ï¼‰
            const particleCount = Math.floor(20 * diversityMultiplier);
            for (let i = 0; i < particleCount; i++) {
                gameState.particles.push(new WaterParticle(x, y));
            }

            // ç†±ã‚¹ãƒãƒƒãƒˆã¨ã®è¡çªåˆ¤å®š
            gameState.heatSpots.forEach(spot => {
                const distance = Math.sqrt((x - spot.x) ** 2 + (y - spot.y) ** 2);
                if (distance < spot.radius && !spot.cooled) {
                    spot.cooled = true;
                    const heatSpotCooling = 2 * diversityMultiplier;
                    gameState.temperature -= heatSpotCooling;
                    gameState.score += Math.floor(100 * diversityMultiplier);
                    
                    // è¿½åŠ ã®å†·å´ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    const bonusParticles = Math.floor(15 * diversityMultiplier);
                    for (let i = 0; i < bonusParticles; i++) {
                        gameState.particles.push(new WaterParticle(spot.x, spot.y));
                    }
                }
            });

            // å±¥æ­´ã‚’æ›´æ–°
            updateSplashHistory(x, y);

            gameState.splashCount++;
            const baseCooling = 0.5 * diversityMultiplier;
            gameState.temperature -= baseCooling;
            gameState.score += Math.floor(10 * diversityMultiplier);

            // æ¸©åº¦ã®ä¸‹é™è¨­å®š
            if (gameState.temperature < 15) {
                gameState.temperature = 15;
            }

            // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯
            if (gameState.temperature <= 20 && !gameState.gameWon) {
                gameState.gameWon = true;
                setTimeout(() => {
                    alert('ğŸ‰ ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ä¸–ç•Œã‚’æ¶¼ã—ãã—ã¾ã—ãŸï¼ ğŸ‰');
                }, 500);
            }

            updateUI();
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¿½åŠ 
        canvas.addEventListener('click', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction);
        canvas.addEventListener('touchmove', handleInteraction);

        // UIæ›´æ–°
        function updateUI() {
            const currentTemp = Math.round(gameState.temperature);
            document.getElementById('temperature').textContent = currentTemp;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('splashCount').textContent = gameState.splashCount;
            document.getElementById('diversityBonus').textContent = gameState.diversityBonus;
            
            // é¡”æ–‡å­—ã‚’æ›´æ–°
            updateEmoticon(currentTemp);
            
            // æ¸©åº¦ãƒãƒ¼ã®æ›´æ–°
            const tempPercent = Math.max(0, Math.min(100, (gameState.temperature - 15) / 25 * 100));
            const barWidth = document.querySelector('.temperature-bar').offsetWidth;
            document.getElementById('tempIndicator').style.left = `${tempPercent * (barWidth - 4) / 100}px`;
            
            // èƒŒæ™¯è‰²ã®å¤‰æ›´
            const hue = Math.max(200, 360 - (gameState.temperature - 15) * 8);
            document.body.style.background = `linear-gradient(to bottom, 
                hsl(${hue}, 70%, 50%) 0%, 
                hsl(${hue}, 50%, 70%) 50%, 
                hsl(${hue}, 30%, 85%) 100%)`;
        }

        // æç”»é–¢æ•°
        function draw() {
            // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            const temp = gameState.temperature;
            if (temp > 30) {
                gradient.addColorStop(0, '#ff6b6b');
                gradient.addColorStop(1, '#ffa8a8');
            } else if (temp > 25) {
                gradient.addColorStop(0, '#ffd93d');
                gradient.addColorStop(1, '#ffe66d');
            } else {
                gradient.addColorStop(0, '#74b9ff');
                gradient.addColorStop(1, '#a7e6ff');
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç†±ã‚¹ãƒãƒƒãƒˆã‚’æç”»
            gameState.heatSpots.forEach(spot => {
                if (!spot.cooled) {
                    const gradient = ctx.createRadialGradient(
                        spot.x, spot.y, 0,
                        spot.x, spot.y, spot.radius
                    );
                    gradient.addColorStop(0, `rgba(255, 100, 100, ${spot.intensity})`);
                    gradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // å†·å´ã•ã‚ŒãŸã‚¹ãƒãƒƒãƒˆ
                    const gradient = ctx.createRadialGradient(
                        spot.x, spot.y, 0,
                        spot.x, spot.y, spot.radius
                    );
                    gradient.addColorStop(0, 'rgba(100, 200, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æç”»
            gameState.particles.forEach(particle => {
                particle.draw();
            });

            // å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            if (gameState.gameWon) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(canvas.width / 2 - 200, canvas.height / 2 - 50, 400, 100);
                ctx.fillStyle = '#0066cc';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ‰ ä¸–ç•ŒãŒæ¶¼ã—ããªã‚Šã¾ã—ãŸï¼ ğŸ‰', canvas.width / 2, canvas.height / 2);
            }
        }

        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop() {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
            gameState.particles.forEach(particle => particle.update());
            gameState.particles = gameState.particles.filter(particle => !particle.isDead());

            // æ™‚é–“çµŒéã«ã‚ˆã‚‹æ¸©åº¦ä¸Šæ˜‡
            if (gameState.splashCount > 0 && !gameState.gameWon) {
                gameState.temperature += 0.02;
                if (gameState.temperature > 40) {
                    gameState.temperature = 40;
                }
            }

            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
        initHeatSpots();
        updateUI();
        gameLoop();
    </script>
</body>
</html>
<!--
    AI Model: Gemini
    Gemini CLI Version: 0.2.0
    Generation Date: 2025-12-11
    User Prompt: vibe codingのパロディでpipe coatingというアプリを考えて作ってください
    AI Approach: Create a single-file web application (index.html) with all necessary HTML, CSS, and JavaScript. The application will use the HTML Canvas API to create an interactive "pipe coating" experience, as a parody of "vibe coding". The user will "coat" a pipe by clicking and dragging the mouse. The design will be industrial-themed.
    Implementation Intent: To develop a joke application that simulates the satisfying feeling of coating a pipe, playing on the concept of "vibe coding" which focuses on the developer's environment and mood.
-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipe Coating</title>
    <style>
        :root {
            --background-color: #2c2c2c;
            --terminal-bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --pipe-color-start: #888;
            --pipe-color-end: #ccc;
            --coating-color: rgba(255, 165, 0, 0.7);
            --highlight-color: #ffa500;
            --prompt-color: #4af626;
            --caret-color: #00ff00; /* Green caret for CLI feel */
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Consolas', 'Monaco', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .container {
            display: flex;
            width: 100%;
            max-width: 1400px;
            height: 90vh;
            border: 2px solid #555;
            overflow: hidden; /* Prevent content overflow */
        }

        .canvas-container {
            flex: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #444;
            padding: 20px;
            border-right: 2px solid #555;
        }

        #pipeCanvas {
            border: 1px solid #666;
            cursor: crosshair;
        }
        
        .terminal {
            flex: 1;
            background-color: var(--terminal-bg-color);
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow-y: hidden;
            position: relative; /* For loading messages */
        }

        .messages {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            margin-bottom: 10px;
            /* Scrollbar styling for better CLI feel */
            scrollbar-width: thin;
            scrollbar-color: #555 #1a1a1a;
        }
        .messages::-webkit-scrollbar {
            width: 8px;
        }
        .messages::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        .messages::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 4px;
            border: 2px solid #1a1a1a;
        }


        .messages .gemini-response {
            color: var(--text-color);
        }
        
        .messages .user-prompt {
            color: var(--prompt-color);
        }
        
        .messages .error {
            color: #ff4d4d;
        }
        
        .messages .thinking {
            color: #888;
            font-style: italic;
        }

        .prompt-container {
            display: flex;
            align-items: center;
            background-color: #2a2a2a; /* Slightly lighter background for prompt */
            border-top: 1px solid #444;
            padding: 8px 0;
            margin-top: auto; /* Push to bottom */
        }

        .prompt-label {
            color: var(--prompt-color);
            margin-right: 8px;
            margin-left: 10px; /* Padding on left */
        }

        #promptInput {
            background-color: transparent;
            border: none;
            color: var(--prompt-color);
            font-family: inherit;
            font-size: 16px;
            flex-grow: 1;
            outline: none;
            caret-color: var(--caret-color); /* Custom caret color */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="pipeCanvas" width="800" height="200"></canvas>
        </div>
        <div class="terminal">
            <div class="messages" id="messages"></div>
            <div class="prompt-container">
                <span class="prompt-label">&gt;</span>
                <input type="text" id="promptInput" autocomplete="off" autofocus />
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const canvas = document.getElementById('pipeCanvas');
            const ctx = canvas.getContext('2d');
            const messagesEl = document.getElementById('messages');
            const promptInput = document.getElementById('promptInput');

            // --- Configuration ---
            const pipe = {
                x: 50,
                y: 75,
                width: canvas.width - 100,
                height: 50,
                sections: 10
            };
            const typingSpeed = 20;
            const thinkingTime = 1000; // 1 second

            // --- State ---
            let isPainting = false;
            let lastX = 0;
            let lastY = 0;
            const coatedSections = new Array(pipe.sections).fill(false);

            // --- Color Palette ---
            const computedStyle = getComputedStyle(document.documentElement);
            const pipeColorStart = computedStyle.getPropertyValue('--pipe-color-start').trim();
            const pipeColorEnd = computedStyle.getPropertyValue('--pipe-color-end').trim();
            const coatingColor = computedStyle.getPropertyValue('--coating-color').trim();

            // --- Core Functions ---

            function resetCanvas() {
                // Reset the canvas context (size hack) and clipping
                canvas.width = canvas.width;
                drawPipe();
                ctx.beginPath();
                ctx.rect(pipe.x, pipe.y, pipe.width, pipe.height);
                ctx.clip();
                coatedSections.fill(false);
            }
            
            function drawPipe() {
                const gradient = ctx.createLinearGradient(pipe.x, pipe.y, pipe.x, pipe.y + pipe.height);
                gradient.addColorStop(0, pipeColorStart);
                gradient.addColorStop(0.5, pipeColorEnd);
                gradient.addColorStop(1, pipeColorStart);
                ctx.fillStyle = gradient;
                ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(pipe.x, pipe.y + 5, pipe.width, 10);
            }

            function typeMessage(text, className, callback) {
                const p = document.createElement('p');
                p.className = className;
                messagesEl.appendChild(p);
                let i = 0;
                function type() {
                    if (i < text.length) {
                        p.textContent += text.charAt(i);
                        i++;
                        messagesEl.scrollTop = messagesEl.scrollHeight;
                        setTimeout(type, typingSpeed);
                    } else if (callback) {
                        callback();
                    }
                }
                type();
            }

            const thinkingMessages = [
                "Analyzing pipe integrity...",
                "Calibrating coating parameters...",
                "Consulting optimal coating strategies...",
                "Calculating material requirements...",
                "Accessing coating knowledge base...",
                "Formulating coating solution...",
                "Pondering the meaning of coating..."
            ];

            function showThinkingMessage(callback) {
                const randomMessage = thinkingMessages[Math.floor(Math.random() * thinkingMessages.length)];
                typeMessage(randomMessage, 'thinking', () => {
                    setTimeout(() => {
                        messagesEl.lastChild.remove(); // Remove thinking message
                        if (callback) callback();
                    }, thinkingTime);
                });
            }

            function autoCoatSection(sectionIndex, silent = false) {
                if (sectionIndex < 0 || sectionIndex >= pipe.sections) {
                    if (!silent) typeMessage(`Error: Section ${sectionIndex} is out of bounds. Use 0-${pipe.sections - 1}.`, 'error');
                    return;
                }
                const sectionWidth = pipe.width / pipe.sections;
                const x = pipe.x + sectionIndex * sectionWidth;
                
                ctx.fillStyle = coatingColor;
                ctx.fillRect(x, pipe.y, sectionWidth, pipe.height);
                coatedSections[sectionIndex] = true;
            }

            // --- Command Handling ---

            function handleCommand(command) {
                const parts = command.toLowerCase().split(' ').filter(p => p);
                const cmd = parts[0];
                const args = parts.slice(1);

                switch (cmd) {
                    case 'help':
                        typeMessage(
`Available commands:
- /help: Shows this message.
- /coat <section|all>: Coats a specific section (0-9) or all sections.
- /status: Shows the current coating status.
- /clear: Resets all coating on the pipe.
- /manual: Provides instructions for manual coating.`
                        , 'gemini-response');
                        break;
                    
                    case 'coat':
                        if (args.length === 0) {
                            typeMessage('Usage: coat <section_number|all>', 'error');
                            break;
                        }
                        if (args[0] === 'all') {
                            typeMessage('Coating all sections...', 'gemini-response', () => {
                                for (let i = 0; i < pipe.sections; i++) {
                                    autoCoatSection(i, true);
                                }
                                typeMessage('All sections coated.', 'gemini-response');
                            });
                        } else {
                            const section = parseInt(args[0], 10);
                            if (!isNaN(section)) {
                                typeMessage(`Coating section ${section}...`, 'gemini-response', () => {
                                    autoCoatSection(section);
                                });
                            } else {
                                typeMessage(`Error: '${args[0]}' is not a valid section number.`, 'error');
                            }
                        }
                        break;
                    
                    case 'status':
                        const coatedCount = coatedSections.filter(Boolean).length;
                        const percentage = (coatedCount / pipe.sections) * 100;
                        let statusReport = `Coating Status: ${coatedCount}/${pipe.sections} sections coated (${percentage.toFixed(0)}%).\n`;
                        statusReport += coatedSections.map((s, i) => s ? `[${i}: coated]` : `[${i}: clear]`).join(' ');
                        typeMessage(statusReport, 'gemini-response');
                        break;

                    case 'clear':
                        typeMessage('Resetting pipe coating...', 'gemini-response', () => {
                             resetCanvas();
                             typeMessage('Pipe is now clear.', 'gemini-response');
                        });
                        break;
                    
                    case 'manual':
                        typeMessage('You can coat the pipe manually by clicking and dragging the mouse over the canvas on the left.', 'gemini-response');
                        break;

                    default:
                        typeMessage(`Unknown command: '${command}'. Type 'help' for a list of commands.`, 'error');
                        break;
                }
            }
            
            // --- Manual Painting ---

            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
            }

            function startPainting(e) {
                isPainting = true;
                const pos = getMousePos(canvas, e);
                [lastX, lastY] = [pos.x, pos.y];
            }

            function stopPainting() { isPainting = false; }

            function paint(e) {
                if (!isPainting) return;
                const pos = getMousePos(canvas, e);
                ctx.beginPath();
                ctx.lineWidth = 20;
                ctx.lineCap = 'round';
                ctx.strokeStyle = coatingColor;
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                [lastX, lastY] = [pos.x, pos.y];
            }

            // --- Initialization ---

            function init() {
                resetCanvas();
                typeMessage('--- Pipe Coating Simulation v1.0 ---', 'gemini-response');
                typeMessage("Welcome. Type '/help' for available commands or '/manual' for manual mode instructions.", 'gemini-response');
                
                // Event Listeners
                promptInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const rawCommand = promptInput.value.trim();
                        if (rawCommand) {
                            const p = document.createElement('p');
                            p.className = 'user-prompt';
                            p.textContent = `> ${rawCommand}`;
                            messagesEl.appendChild(p);

                            if (rawCommand.startsWith('/')) {
                                const command = rawCommand.substring(1); // Remove the leading '/'
                                // Show thinking message before executing command
                                showThinkingMessage(() => {
                                    handleCommand(command);
                                });
                            } else {
                                // Non-command input, perform a "random" action
                                showThinkingMessage(() => {
                                    const uncoatedSections = coatedSections
                                        .map((isCoated, index) => isCoated ? -1 : index)
                                        .filter(index => index !== -1);
                                    
                                    if (uncoatedSections.length > 0) {
                                        const randomSection = uncoatedSections[Math.floor(Math.random() * uncoatedSections.length)];
                                        typeMessage(`Based on my analysis of your input, section ${randomSection} requires immediate attention.`, 'gemini-response', () => {
                                            autoCoatSection(randomSection);
                                        });
                                    } else {
                                        typeMessage('Pipe is fully coated. My work here is done.', 'gemini-response');
                                    }
                                });
                            }
                        }
                        promptInput.value = '';
                        messagesEl.scrollTop = messagesEl.scrollHeight;
                    }
                });

                canvas.addEventListener('mousedown', startPainting);
                canvas.addEventListener('mouseup', stopPainting);
                canvas.addEventListener('mouseleave', stopPainting);
                canvas.addEventListener('mousemove', paint);
            }

            init();
        });
    </script>
</body>
</html>

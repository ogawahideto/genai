<!--
    AI Model: Gemini
    Gemini CLI Version: 0.2.0
    Generation Date: 2025-12-11
    User Prompt: vibe codingのパロディでpipe coatingというアプリを考えて作ってください
    AI Approach: Create a single-file web application (index.html) with all necessary HTML, CSS, and JavaScript. The application will use the HTML Canvas API to create an interactive "pipe coating" experience, as a parody of "vibe coding". The user will "coat" a pipe by clicking and dragging the mouse. The design will be industrial-themed.
    Implementation Intent: To develop a joke application that simulates the satisfying feeling of coating a pipe, playing on the concept of "vibe coding" which focuses on the developer's environment and mood.
-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipe Coating</title>
    <style>
        :root {
            /* Gemini-like Color Palette */
            --background-color: #131314;
            --terminal-bg-color: #1e1f22;
            --prompt-bg-color: #282a2e;
            --code-bg-color: #282a2e;
            --text-color: #e8eaed;
            --thinking-color: #9aa0a6;
            --prompt-color: #bdc1c6;
            --prompt-label-color: #8ab4f8;
            --error-color: #f28b82;
            --caret-color: #8ab4f8;
            --border-color: #3c4043;

            /* Pseudo-code syntax colors */
            --code-keyword: #c586c0;
            --code-fn: #dcdcaa;
            --code-comment: #6a9955;
            --code-value: #9cdcfe;
            --code-bool-true: #569cd6;
            --code-bool-false: #ce9178;

            /* Industrial Theme */
            --pipe-color-start: #888;
            --pipe-color-end: #ccc;
            --coating-color: rgba(255, 165, 0, 0.7);
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Consolas', 'Monaco', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .container {
            display: flex;
            width: 100%;
            max-width: 1600px; /* Increased max-width */
            height: 90vh;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .canvas-container {
            flex: 3; /* Give more space to the canvas + code editor */
            display: flex;
            flex-direction: column; /* Align canvas and code editor vertically */
            background-color: var(--background-color);
            border-right: 1px solid var(--border-color);
        }
        
        .canvas-wrapper {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #pipeCanvas {
            border: 1px solid var(--border-color);
            cursor: crosshair;
            width: 100%;
            max-width: 800px;
        }

        #pseudoCodeEditor {
            background-color: var(--code-bg-color);
            height: 40%;
            border-top: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 15px;
            font-size: 14px;
            white-space: pre;
        }
        
        #pseudoCodeEditor .code-keyword { color: var(--code-keyword); }
        #pseudoCodeEditor .code-fn { color: var(--code-fn); }
        #pseudoCodeEditor .code-comment { color: var(--code-comment); }
        #pseudoCodeEditor .code-value { color: var(--code-value); }
        #pseudoCodeEditor .code-bool-true { color: var(--code-bool-true); }
        #pseudoCodeEditor .code-bool-false { color: var(--code-bool-false); }

        .terminal {
            flex: 1;
            background-color: var(--terminal-bg-color);
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow-y: hidden;
            position: relative;
        }

        .messages {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.5;
            padding: 15px;
            white-space: pre-wrap;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) var(--terminal-bg-color);
        }
        .messages::-webkit-scrollbar { width: 8px; }
        .messages::-webkit-scrollbar-track { background: var(--terminal-bg-color); }
        .messages::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 4px; border: 2px solid var(--terminal-bg-color); }

        .messages .gemini-response, .messages .user-prompt, .messages .error, .messages .thinking {
            color: var(--text-color);
        }
        .messages .user-prompt { color: var(--prompt-color); }
        .messages .error { color: var(--error-color); }
        .messages .thinking { color: var(--thinking-color); font-style: italic; }

        .prompt-container {
            display: flex;
            align-items: center;
            background-color: var(--prompt-bg-color);
            border-top: 1px solid var(--border-color);
            padding: 8px 15px;
            margin-top: auto;
        }

        .prompt-label {
            color: var(--prompt-label-color);
            margin-right: 8px;
        }

        #promptInput {
            background-color: transparent;
            border: none;
            color: var(--prompt-color);
            font-family: inherit;
            font-size: 16px;
            flex-grow: 1;
            outline: none;
            caret-color: var(--caret-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="pipeCanvas" width="800" height="200"></canvas>
            </div>
            <div id="pseudoCodeEditor"></div>
        </div>
        <div class="terminal">
            <div class="messages" id="messages"></div>
            <div class="prompt-container">
                <span class="prompt-label">&gt;</span>
                <input type="text" id="promptInput" autocomplete="off" autofocus />
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const canvas = document.getElementById('pipeCanvas');
            const ctx = canvas.getContext('2d');
            const messagesEl = document.getElementById('messages');
            const promptInput = document.getElementById('promptInput');
            const pseudoCodeEditor = document.getElementById('pseudoCodeEditor');

            // --- Configuration ---
            const pipe = {
                x: 50,
                y: 75,
                width: canvas.width - 100,
                height: 50,
                sections: 10
            };
            const typingSpeed = 20;
            const thinkingTime = 1000;
            const thinkingMessages = [
                "Analyzing pipe integrity...",
                "Calibrating coating parameters...",
                "Refactoring pipe_coating_logic.rs...",
                "Calculating material requirements...",
                "Accessing coating knowledge base...",
                "Formulating coating solution...",
                "Pondering the meaning of coating..."
            ];

            // --- State ---
            let isPainting = false;
            let lastX = 0;
            let lastY = 0;
            const coatedSections = new Array(pipe.sections).fill(false);

            // --- Color Palette ---
            const computedStyle = getComputedStyle(document.documentElement);
            const coatingColor = computedStyle.getPropertyValue('--coating-color').trim();

            // --- Core Functions ---

            function renderPseudoCode() {
                let code = `<span class="code-comment">// pipe_coating_logic.rs</span>\n`;
                code += `<span class="code-keyword">fn</span> <span class="code-fn">apply_coating</span>(<span class="code-value">pipe</span>: &<span class="code-keyword">mut</span> Pipe) {\n`;
                code += `    <span class="code-keyword">let</span> sections = [\n`;
                for (let i = 0; i < pipe.sections; i++) {
                    const coated = coatedSections[i];
                    const boolClass = coated ? 'code-bool-true' : 'code-bool-false';
                    code += `        Section { coated: <span class="${boolClass}">${coated}</span> }, <span class="code-comment">// section ${i}</span>\n`;
                }
                code += `    ];\n`;
                code += `\n`;
                code += `    <span class="code-comment">// Begin highly optimized and complex coating logic (Rust-like)</span>\n`;
                code += `    <span class="code-keyword">let</span> <span class="code-fn">coating_material</span> = <span class="code-fn">fetch_from_supply_chain</span>(<span class="code-value">material_id</span>); <span class="code-comment">// Asynchronous fetch</span>\n`;
                code += `    <span class="code-keyword">match</span> <span class="code-fn">validate_purity</span>(&<span class="code-fn">coating_material</span>) {\n`;
                code += `        <span class="code-keyword">Ok</span>(<span class="code-bool-true">true</span>) => <span class="code-comment">// Proceed with application</span>\n`;
                code += `            <span class="code-keyword">for</span> <span class="code-value">section</span> <span class="code-keyword">in</span> <span class="code-value">sections.iter_mut</span>() {\n`;
                code += `                <span class="code-keyword">if</span> !<span class="code-value">section.coated</span> {\n`;
                code += `                    <span class="code-fn">apply_layer</span>(&<span class="code-keyword">mut</span> <span class="code-value">section</span>, &<span class="code-fn">coating_material</span>, <span class="code-value">100.0</span>); <span class="code-comment">// 100% coverage</span>\n`;
                code += `                    <span class="code-value">section.coated</span> = <span class="code-bool-true">true</span>;\n`;
                code += `                    <span class="code-keyword">let</span> <span class="code-fn">checksum</span> = <span class="code-fn">calculate_integrity_checksum</span>(&<span class="code-value">section</span>); \n`;
                code += `                    <span class="code-fn">report_status</span>(<span class="code-value">section.id</span>, <span class="code-value">checksum</span>);\n`;
                code += `                }\n`;
                code += `            }\n`;
                code += `        <span class="code-keyword">Err</span>(<span class="code-value">e</span>) => <span class="code-fn">log_error</span>(<span class="code-string">"Coating material impure"</span>, <span class="code-value">e</span>),\n`;
                code += `        <span class="code-keyword">_</span> => <span class="code-fn">panic</span>!(<span class="code-string">"Unexpected validation result"</span>),\n`;
                code += `    }\n`;
                code += `    <span class="code-fn">optimize_coating_flow</span>(<span class="code-value">pipe</span>);\n`;
                code += `    <span class="code-comment">// End highly optimized and complex coating logic</span>\n`;
                code += `}`;
                pseudoCodeEditor.innerHTML = code;
            }

            function resetCanvas() {
                canvas.width = canvas.width;
                const pipeColorStart = computedStyle.getPropertyValue('--pipe-color-start').trim();
                const pipeColorEnd = computedStyle.getPropertyValue('--pipe-color-end').trim();
                const gradient = ctx.createLinearGradient(pipe.x, pipe.y, pipe.x, pipe.y + pipe.height);
                gradient.addColorStop(0, pipeColorStart);
                gradient.addColorStop(0.5, pipeColorEnd);
                gradient.addColorStop(1, pipeColorStart);
                ctx.fillStyle = gradient;
                ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(pipe.x, pipe.y + 5, pipe.width, 10);
                
                ctx.beginPath();
                ctx.rect(pipe.x, pipe.y, pipe.width, pipe.height);
                ctx.clip();
                coatedSections.fill(false);
                renderPseudoCode();
            }

            function typeMessage(text, className, callback) {
                const p = document.createElement('p');
                p.className = className;
                messagesEl.appendChild(p);
                let i = 0;
                function type() {
                    if (i < text.length) {
                        p.textContent += text.charAt(i);
                        i++;
                        messagesEl.scrollTop = messagesEl.scrollHeight;
                        setTimeout(type, typingSpeed);
                    } else if (callback) {
                        callback();
                    }
                }
                type();
            }

            function showThinkingMessage(callback) {
                const randomMessage = thinkingMessages[Math.floor(Math.random() * thinkingMessages.length)];
                typeMessage(randomMessage, 'thinking', () => {
                    setTimeout(() => {
                        const thinkingMessageEl = messagesEl.querySelector('.thinking');
                        if(thinkingMessageEl) thinkingMessageEl.remove();
                        if (callback) callback();
                    }, thinkingTime);
                });
            }

            function autoCoatSection(sectionIndex, silent = false) {
                if (sectionIndex < 0 || sectionIndex >= pipe.sections) {
                    if (!silent) typeMessage(`Error: Section ${sectionIndex} is out of bounds. Use 0-${pipe.sections - 1}.`, 'error');
                    return;
                }
                const sectionWidth = pipe.width / pipe.sections;
                const x = pipe.x + sectionIndex * sectionWidth;
                
                ctx.fillStyle = coatingColor;
                ctx.fillRect(x, pipe.y, sectionWidth, pipe.height);
                if (!coatedSections[sectionIndex]) {
                    coatedSections[sectionIndex] = true;
                    renderPseudoCode();
                }
            }

            function handleCommand(command) {
                const parts = command.toLowerCase().split(' ').filter(p => p);
                const cmd = parts[0];
                const args = parts.slice(1);

                switch (cmd) {
                    case 'help':
                        typeMessage(`Available commands:\n- /help: Shows this message.\n- /coat <section|all>: Coats a specific section (0-9) or all sections.\n- /status: Shows the current coating status.\n- /clear: Resets all coating on the pipe.\n- /manual: Provides instructions for manual coating.`, 'gemini-response');
                        break;
                    
                    case 'coat':
                        if (args.length === 0) {
                            typeMessage('Usage: /coat <section_number|all>', 'error');
                            break;
                        }
                        if (args[0] === 'all') {
                            typeMessage('Refactoring all sections in pipe_coating_logic.rs...', 'gemini-response', () => {
                                for (let i = 0; i < pipe.sections; i++) {
                                    autoCoatSection(i, true);
                                }
                                typeMessage('All sections coated.', 'gemini-response');
                            });
                        } else {
                            const section = parseInt(args[0], 10);
                            if (!isNaN(section)) {
                                typeMessage(`Refactoring section ${section} in pipe_coating_logic.rs...`, 'gemini-response', () => {
                                    autoCoatSection(section);
                                });
                            } else {
                                typeMessage(`Error: '${args[0]}' is not a valid section number.`, 'error');
                            }
                        }
                        break;
                    
                    case 'status':
                        const coatedCount = coatedSections.filter(Boolean).length;
                        const percentage = (coatedCount / pipe.sections) * 100;
                        let statusReport = `Coating Status: ${coatedCount}/${pipe.sections} sections coated (${percentage.toFixed(0)}%).\n`;
                        statusReport += coatedSections.map((s, i) => s ? `[${i}: coated]` : `[${i}: clear]`).join(' ');
                        typeMessage(statusReport, 'gemini-response');
                        break;

                    case 'clear':
                        typeMessage('Reverting changes in pipe_coating_logic.rs...', 'gemini-response', () => {
                             resetCanvas();
                             typeMessage('Pipe is now clear.', 'gemini-response');
                        });
                        break;
                    
                    case 'manual':
                        typeMessage('You can coat the pipe manually by clicking and dragging the mouse over the canvas.', 'gemini-response');
                        break;

                    default:
                        typeMessage(`Unknown command: '${command}'. Type '/help' for a list of commands.`, 'error');
                        break;
                }
            }
            
            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
            }

            function startPainting(e) {
                isPainting = true;
                const pos = getMousePos(canvas, e);
                [lastX, lastY] = [pos.x, pos.y];
            }

            function stopPainting() { isPainting = false; }

            function paint(e) {
                if (!isPainting) return;
                const pos = getMousePos(canvas, e);
                ctx.beginPath();
                ctx.lineWidth = 20;
                ctx.lineCap = 'round';
                ctx.strokeStyle = coatingColor;
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();

                const midX = (lastX + pos.x) / 2;
                if (midX >= pipe.x && midX <= pipe.x + pipe.width) {
                    const sectionIndex = Math.floor(((midX - pipe.x) / pipe.width) * pipe.sections);
                    if (sectionIndex >= 0 && sectionIndex < pipe.sections && !coatedSections[sectionIndex]) {
                        coatedSections[sectionIndex] = true;
                        renderPseudoCode();
                    }
                }
                [lastX, lastY] = [pos.x, pos.y];
            }

            function init() {
                resetCanvas();
                typeMessage('--- Pipe Coating Simulation v1.0 ---', 'gemini-response');
                typeMessage("Welcome. Type '/help' for available commands or '/manual' for manual mode instructions.", 'gemini-response');
                
                promptInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const rawCommand = promptInput.value.trim();
                        if (rawCommand) {
                            const p = document.createElement('p');
                            p.className = 'user-prompt';
                            p.textContent = `> ${rawCommand}`;
                            messagesEl.appendChild(p);

                            if (rawCommand.startsWith('/')) {
                                const command = rawCommand.substring(1);
                                showThinkingMessage(() => {
                                    handleCommand(command);
                                });
                            } else {
                                showThinkingMessage(() => {
                                    const uncoatedSections = coatedSections.map((isCoated, index) => isCoated ? -1 : index).filter(index => index !== -1);
                                    if (uncoatedSections.length > 0) {
                                        const randomSection = uncoatedSections[Math.floor(Math.random() * uncoatedSections.length)];
                                        typeMessage(`Based on my analysis of your input, section ${randomSection} requires immediate attention.`, 'gemini-response', () => {
                                            autoCoatSection(randomSection);
                                        });
                                    } else {
                                        typeMessage('Pipe is fully coated. My work here is done.', 'gemini-response');
                                    }
                                });
                            }
                        }
                        promptInput.value = '';
                        messagesEl.scrollTop = messagesEl.scrollHeight;
                    }
                });

                canvas.addEventListener('mousedown', startPainting);
                canvas.addEventListener('mouseup', stopPainting);
                canvas.addEventListener('mouseleave', stopPainting);
                canvas.addEventListener('mousemove', paint);
            }

            init();
        });
    </script>
</body>
</html>

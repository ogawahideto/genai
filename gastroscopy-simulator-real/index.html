<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Gastroscopy Simulator v6.1 (Fixed Tracker)</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #minimap-container {
            position: absolute; bottom: 20px; right: 20px; width: 200px; height: 200px;
            border: 2px solid #00ffcc; background: #000; z-index: 50;
            border-radius: 4px; overflow: hidden; pointer-events: auto;
        }
        #minimap-label { position: absolute; top: 2px; left: 5px; color: #00ffcc; font-size: 10px; z-index: 52; font-weight: bold; font-family: monospace; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 10; pointer-events: none; }
        .osd-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #ui-controls { position: absolute; top: 120px; left: 20px; z-index: 30; font-family: 'Courier New', Courier, monospace; color: #00ffcc; font-size: 12px; pointer-events: auto; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 4px; }
        #brightness-slider { width: 80px; vertical-align: middle; cursor: pointer; }
        .btn-capture { margin-top: 10px; background: #ff3333; color: white; border: none; padding: 5px 10px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold; border-radius: 2px; width: 100%; }
        #gallery { position: absolute; top: 120px; right: 20px; width: 120px; z-index: 40; display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
        .gallery-item { width: 100%; border: 1px solid #00ffcc; cursor: pointer; transition: transform 0.2s; background: #000; }
        .gallery-label { color: #00ffcc; font-size: 10px; text-align: center; font-family: monospace; background: rgba(0,0,0,0.5); }
        #shutter-flash { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: white; z-index: 100; opacity: 0; pointer-events: none; }
        .flash-active { animation: flash-anim 0.3s ease-out; }
        @keyframes flash-anim { 0% { opacity: 1; } 100% { opacity: 0; } }
        
        /* Mobile Controls */
        .touch-zone {
            position: absolute; bottom: 20px; width: 120px; height: 120px;
            border: 2px solid rgba(0, 255, 204, 0.3); border-radius: 50%;
            background: rgba(0, 0, 0, 0.2); pointer-events: auto; touch-action: none;
            display: flex;
        }
        .touch-knob {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            background: rgba(0, 255, 204, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #stick-left { left: 20px; }
        #stick-right { right: 20px; }
        #mobile-capture {
            position: absolute; top: 120px; right: 20px; width: 60px; height: 60px;
            background: rgba(255, 51, 51, 0.8); border-radius: 50%; border: 2px solid white;
            color: white; font-weight: bold; display: none; pointer-events: auto;
            align-items: center; justify-content: center; font-family: monospace; cursor: pointer;
            z-index: 60;
        }

        #pathology-log { position: absolute; top: 220px; left: 20px; width: 250px; font-family: 'Courier New', monospace; color: #ff3333; z-index: 5; text-shadow: 1px 1px 0 #000; pointer-events: none; }
        #location-display { position: absolute; top: 90px; right: 20px; color: #ff9900; font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold; z-index: 5; text-shadow: 0 0 2px #f00; text-align: right; }
        #controls-display { position: absolute; top: 320px; left: 20px; color: rgba(0, 255, 204, 0.7); font-family: 'Courier New', monospace; font-size: 10px; z-index: 5; pointer-events: none; }

        @media (max-width: 768px) {
            #mobile-capture { display: flex; }
            #ui-controls, #gallery, #controls-display { display: none; }
            #minimap-container { top: 10px; left: 10px; bottom: auto; right: auto; width: 100px; height: 100px; }
            #location-display { font-size: 12px; top: 10px; right: 10px; }
            #pathology-log { top: 50px; left: 10px; font-size: 10px; }
            #depth-indicator { font-size: 12px; margin-right: 10px !important; bottom: 150px; right: 10px; position: absolute;}
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="minimap-container"><div id="minimap-label">POS TRACKER</div></div>
    <div id="shutter-flash"></div>

    <div id="stick-left" class="touch-zone"><div class="touch-knob"></div></div>
    <div id="stick-right" class="touch-zone"><div class="touch-knob"></div></div>
    <div id="mobile-capture">SNAP</div>

    <div id="ui-overlay">
        <div class="monitor-mask"></div>
        <div class="osd-layer">
            <div class="osd-top-left">
                <div class="patient-info"><span class="label">NAME:</span> GEMINI, DUMMY<br><span class="label">ID:</span> 2026-0131-X<br><span class="label">DOB:</span> 1990/01/01<br><span class="label">SEX:</span> M</div>
            </div>
            <div id="ui-controls">BRIGHTNESS: <input type="range" id="brightness-slider" min="0.5" max="5.0" step="0.1" value="1.5"><br><button class="btn-capture" id="btn-capture">PHOTO [P]</button></div>
            <div id="gallery"><div class="gallery-label">CAPTURES</div></div>
            <div id="pathology-log"><strong>[PATHOLOGY LOG]</strong><br></div>
            <div class="osd-top-right"><div class="hospital-info">GEMINI GEN AI CLINIC<br>GIF-H290Z</div><div id="timestamp">--:--:--</div></div>
            <div id="location-display">LOC: ESOPHAGUS</div>
            <div id="controls-display">[CONTROLS]<br><strong>W / S</strong> : Insert/Back<br><strong>Arrows</strong>: Angulation (Turn)<br><strong>Shift+W</strong>: Force Move<br><strong>M</strong>: Adjust Mode</div>
            <div class="osd-bottom-left"><div class="scope-status"><span class="label">ENHANCE:</span> A1<br><span class="label">IRIS:</span> AUTO</div></div>
            <div class="osd-bottom-right"><div id="depth-indicator" style="margin-right: 210px;">INSERT: 0 cm</div></div>
        </div>
        <div class="scanlines"></div><div class="noise"></div>
    </div>

    <div id="instructions">
        <h2>GASTROSCOPY SIMULATOR V6.1</h2>
        <p id="loading-status" style="color: cyan; margin-top: 20px;">LOADING MODEL...</p>
        <p id="start-btn" style="color: yellow; margin-top: 20px; cursor: pointer; border: 1px solid yellow; padding: 10px; display: none;">CLICK TO START</p>
        <p id="error-msg" style="color: red; margin-top: 20px; display: none;">ERROR: Model failed to load.</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/loaders/GLTFLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js",
                "three/addons/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
                "three/addons/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
                "three/addons/postprocessing/RenderPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
                "three/addons/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        const CONFIG = { moveSpeed: 0.0003, torqueSpeed: 0.03, angulationSpeed: 0.04 };
        const state = { 
            progress: 0.015, torque: 0, angulation: new THREE.Vector2(0, 0), roll: 0, 
            exposure: 2.8, nbi: false 
        };
        const inputs = { forward: false, backward: false, rotateLeft: false, rotateRight: false, angUp: false, angDown: false, angLeft: false, angRight: false, shift: false };

        // Globals
        let stomachModel = null;
        const lesions = [];
        const raycaster = new THREE.Raycaster();
        const loader = new GLTFLoader();

        // Main Scene
        const mainRenderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        mainRenderer.setSize(window.innerWidth, window.innerHeight);
        mainRenderer.toneMapping = THREE.ACESFilmicToneMapping;
        mainRenderer.toneMappingExposure = state.exposure;
        document.getElementById('canvas-container').appendChild(mainRenderer.domElement);
        
        const mainScene = new THREE.Scene(); 
        mainScene.background = new THREE.Color(0x1a0505);
        mainScene.fog = new THREE.FogExp2(0x1a0505, 0.002);
        const mainCamera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.05, 1000);

        // Lens Distortion Shader
        const LensDistortionShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "strength": { value: 0.35 },
                "height": { value: 1.0 },
                "aspect": { value: window.innerWidth / window.innerHeight }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float strength;
                uniform float aspect;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv - 0.5;
                    float dist = length(uv);
                    
                    // Barrel Distortion
                    uv *= 1.0 + strength * (dist * dist);
                    
                    // Chromatic Aberration
                    vec2 uvR = uv * (1.0 + 0.02 * strength) + 0.5;
                    vec2 uvG = uv + 0.5;
                    vec2 uvB = uv * (1.0 - 0.02 * strength) + 0.5;

                    if (uvG.x < 0.0 || uvG.x > 1.0 || uvG.y < 0.0 || uvG.y > 1.0) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        return;
                    }

                    float r = texture2D(tDiffuse, uvR).r;
                    float g = texture2D(tDiffuse, uvG).g;
                    float b = texture2D(tDiffuse, uvB).b;
                    
                    // Vignette (Circular Mask) - Softened for better visibility
                    float vignette = smoothstep(0.9, 0.4, dist * 1.5);
                    
                    gl_FragColor = vec4(vec3(r, g, b) * vignette, 1.0);
                }
            `
        };

        const composer = new EffectComposer(mainRenderer);
        composer.addPass(new RenderPass(mainScene, mainCamera));
        const distortionPass = new ShaderPass(LensDistortionShader);
        composer.addPass(distortionPass);

        // Minimap
        const mapRenderer = new THREE.WebGLRenderer({ antialias: true });
        mapRenderer.setSize(200, 200);
        document.getElementById('minimap-container').appendChild(mapRenderer.domElement);
        const mapScene = new THREE.Scene(); mapScene.background = new THREE.Color(0x000000); 
        const mapCamera = new THREE.PerspectiveCamera(45, 1, 10, 1000);
        mapCamera.position.set(200, 50, 200); 
        const mapControls = new OrbitControls(mapCamera, mapRenderer.domElement);
        mapControls.enableDamping = true;
        mapControls.dampingFactor = 0.05;

        // Player Marker Group
        const playerMarker = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshBasicMaterial({color: 0xff0000}));
        const directionCone = new THREE.Mesh(new THREE.ConeGeometry(1, 5, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        directionCone.position.z = -3; directionCone.rotation.x = -Math.PI / 2;
        const playerGroup = new THREE.Group();
        playerGroup.add(playerMarker); playerGroup.add(directionCone);
        mapScene.add(playerGroup);

        // Controls
        const manualControl = { x: 0.5, y: 194, z: -10.5 }; 
        const currentPos = new THREE.Vector3(manualControl.x, manualControl.y, manualControl.z);

        // Trail and Distance Tracking
        const trailPoints = [];
        const trailGeometry = new THREE.BufferGeometry();
        const trailMaterial = new THREE.PointsMaterial({ 
            color: 0xff0000, 
            size: 5.0, 
            transparent: true, 
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            depthTest: false
        });
        const trailMesh = new THREE.Points(trailGeometry, trailMaterial);
        trailMesh.frustumCulled = false;
        mapScene.add(trailMesh);
        const lastTrailPos = new THREE.Vector3().copy(currentPos);
        const lastFramePos = new THREE.Vector3().copy(currentPos);
        let totalDistance = 0;
        let insertDepth = 0;

        // Reset Tracker Function
        const resetTracker = () => {
            trailPoints.length = 0;
            trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
            totalDistance = 0;
            insertDepth = 0;
            lastTrailPos.copy(currentPos);
            lastFramePos.copy(currentPos);
            const log = document.getElementById('pathology-log');
            const div = document.createElement('div'); div.style.color = '#00ffcc'; div.innerText = `> TRACKER RESET`;
            log.appendChild(div);
        };

        // Load Model
        loader.load('realistic_human_stomach.glb', (gltf) => {
            stomachModel = gltf.scene;
            const box = new THREE.Box3().setFromObject(stomachModel);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            stomachModel.position.set(-center.x, -box.max.y, -center.z);
            const desiredHeight = 200;
            const scaleFactor = desiredHeight / size.y;
            if (size.y < 50 || size.y > 500) stomachModel.scale.multiplyScalar(scaleFactor);

            stomachModel.traverse((child) => {
                if (child.isMesh) {
                    const oldMat = child.material;
                    child.material = new THREE.MeshPhysicalMaterial({
                        color: oldMat.color || 0xffaaaa,
                        map: oldMat.map || null,
                        normalMap: oldMat.normalMap || null,
                        roughness: 0.08,
                        metalness: 0.0,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.03,
                        reflectivity: 0.9,
                        transmission: 0.1, // Slight subsurface translucency
                        thickness: 1.0,
                        side: THREE.DoubleSide
                    });
                }
            });
            stomachModel.updateMatrixWorld();
            mainScene.add(stomachModel);
            
            // Lesions
            const tempRay = new THREE.Raycaster();
            for(let i=0; i<15; i++) {
                for(let a=0; a<10; a++) {
                    const origin = new THREE.Vector3((Math.random()-0.5)*size.x*scaleFactor, (Math.random()-0.5)*size.y*scaleFactor-100, (Math.random()-0.5)*size.z*scaleFactor);
                    const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                    tempRay.set(origin, dir);
                    const hits = tempRay.intersectObject(stomachModel, true);
                    if(hits.length > 0) {
                        const hit = hits[0];
                        const lmesh = new THREE.Mesh(new THREE.SphereGeometry(2,16,16,0,Math.PI*2,0,Math.PI*0.7), new THREE.MeshPhysicalMaterial({color:0xcc0000, roughness:0.1, clearcoat:1.0}));
                        lmesh.position.copy(hit.point);
                        lmesh.lookAt(hit.point.clone().add(hit.face.normal.clone().applyQuaternion(hit.object.quaternion)));
                        mainScene.add(lmesh);
                        lesions.push({ mesh: lmesh, found: false, position: hit.point });
                        break;
                    }
                }
            }

            const mapModel = stomachModel.clone();
            mapModel.traverse(c => { if(c.isMesh) c.material = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true, transparent:true, opacity:0.3}); });
            mapScene.add(mapModel);
            
            document.getElementById('loading-status').style.display = 'none';
            document.getElementById('start-btn').style.display = 'inline-block';
        }, undefined, (err) => {
            console.error(err);
            document.getElementById('loading-status').style.display = 'none';
            document.getElementById('error-msg').style.display = 'block';
        });

        // Controls
        let isAdjustmentMode = false;
        const adjustmentInputs = { xPlus: false, xMinus: false, yPlus: false, yMinus: false, zPlus: false, zMinus: false };
        let coordDisplay = document.getElementById('coord-display') || document.createElement('div');
        if(!coordDisplay.parentNode) {
            coordDisplay.id = 'coord-display';
            coordDisplay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: lime; font-family: monospace; font-size: 20px; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid lime; display: none; z-index: 1000;';
            document.body.appendChild(coordDisplay);
        }

        const hemiLight = new THREE.HemisphereLight( 0xffaaaa, 0x440000, 0.8 );
        mainScene.add( hemiLight );
        const scopeLight = new THREE.SpotLight(0xfff0e0, 60.0, 300, 0.8, 0.5, 0.8);
        mainCamera.add(scopeLight); mainCamera.add(scopeLight.target); mainScene.add(mainCamera);
        scopeLight.target.position.set(0, 0, -1);

        // Interaction Listeners
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(e.shiftKey) inputs.shift = true;
            if (k === 'm') { isAdjustmentMode = !isAdjustmentMode; coordDisplay.style.display = isAdjustmentMode ? 'block' : 'none'; }
            if (k === 'n') toggleNBI();
            if(k==='w') inputs.forward=true; if(k==='s') inputs.backward=true;
            if(k==='a') inputs.rotateLeft=true; if(k==='d') inputs.rotateRight=true;
            if(k==='arrowup') inputs.angUp=true; if(k==='arrowdown') inputs.angDown=true;
            if(k==='arrowleft') inputs.angLeft=true; if(k==='arrowright') inputs.angRight=true;
            if(k==='p' || e.key==='Enter') takePhoto();
            if(k==='r') resetTracker();
            if (isAdjustmentMode) {
                if(k==='i') adjustmentInputs.yPlus = true; if(k==='k') adjustmentInputs.yMinus = true;
                if(k==='j') adjustmentInputs.xMinus = true; if(k==='l') adjustmentInputs.xPlus = true;
                if(k==='u') adjustmentInputs.zMinus = true; if(k==='o') adjustmentInputs.zPlus = true;
            }
        });

        const toggleNBI = () => {
            state.nbi = !state.nbi;
            const canvas = mainRenderer.domElement;
            if (state.nbi) {
                scopeLight.color.set(0x44ffaa); // Cyan-greenish NBI light
                canvas.style.filter = "contrast(1.2) saturate(1.5) hue-rotate(-10deg)";
                const div = document.createElement('div'); div.style.color = '#00ffcc'; div.innerText = `> NBI MODE: ON`;
                document.getElementById('pathology-log').appendChild(div);
            } else {
                scopeLight.color.set(0xfff0e0); // Warm white light
                canvas.style.filter = "none";
                const div = document.createElement('div'); div.style.color = '#00ffcc'; div.innerText = `> NBI MODE: OFF`;
                document.getElementById('pathology-log').appendChild(div);
            }
        };
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(!e.shiftKey) inputs.shift = false;
            if(k==='w') inputs.forward=false; if(k==='s') inputs.backward=false;
            if(k==='a') inputs.rotateLeft=false; if(k==='d') inputs.rotateRight=false;
            if(k==='arrowup') inputs.angUp=false; if(k==='arrowdown') inputs.angDown=false;
            if(k==='arrowleft') inputs.angLeft=false; if(k==='arrowright') inputs.angRight=false;
            if (isAdjustmentMode) {
                if(k==='i') adjustmentInputs.yPlus = false; if(k==='k') adjustmentInputs.yMinus = false;
                if(k==='j') adjustmentInputs.xMinus = false; if(k==='l') adjustmentInputs.xPlus = false;
                if(k==='u') adjustmentInputs.zMinus = false; if(k==='o') adjustmentInputs.zPlus = false;
            }
        });

        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            state.exposure = parseFloat(e.target.value);
            mainRenderer.toneMappingExposure = state.exposure;
        });
        document.getElementById('start-btn').onclick = function() { document.getElementById('instructions').style.display = 'none'; };

        const takePhoto = () => {
            const flash = document.getElementById('shutter-flash');
            flash.classList.remove('flash-active'); void flash.offsetWidth; flash.classList.add('flash-active');
            const dataUrl = mainRenderer.domElement.toDataURL("image/png");
            const gallery = document.getElementById('gallery');
            const img = document.createElement('img');
            img.src = dataUrl; img.className = 'gallery-item';
            img.onclick = () => { const link = document.createElement('a'); link.download = `gastroscopy_${new Date().getTime()}.png`; link.href = dataUrl; link.click(); };
            gallery.insertBefore(img, gallery.children[1]);
        };

        // Collision Logic
        const OUTER_RADIUS = 1.5;
        const INNER_RADIUS = 0.4;
        function resolveCollisions(position) {
            if (!stomachModel) return position;
            const dirs = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)];
            let adjustedPos = position.clone();
            for(let dir of dirs) {
                raycaster.set(adjustedPos, dir);
                const hits = raycaster.intersectObject(stomachModel, true);
                if (hits.length > 0) {
                    const hit = hits[0];
                    let n = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                    if (n.dot(dir) > 0) n.negate();
                    if (hit.distance < INNER_RADIUS) adjustedPos.add(n.multiplyScalar(INNER_RADIUS - hit.distance));
                    else if (hit.distance < OUTER_RADIUS) adjustedPos.add(n.multiplyScalar((OUTER_RADIUS - hit.distance) * 0.1));
                }
            }
            return adjustedPos;
        }

        const LOCATIONS = {
            ESOPHAGUS: { en: "ESOPHAGUS", jp: "食道", threshold: 0 },
            STOMACH_UPPER: { en: "STOMACH (FUNDUS)", jp: "胃（胃底部）", threshold: 120 },
            STOMACH_MID: { en: "STOMACH (BODY)", jp: "胃（胃体部）", threshold: 130 },
            STOMACH_LOWER: { en: "STOMACH (ANTRUM)", jp: "胃（前庭部）", threshold: 140 },
            DUODENUM: { en: "DUODENUM", jp: "十二指腸", threshold: 150 },
            SMALL_INTESTINE: { en: "SMALL INTESTINE", jp: "小腸", threshold: 180 },
            LARGE_INTESTINE: { en: "LARGE INTESTINE", jp: "大腸", threshold: 250 }
        };

        function update() {
            const speed = 0.5;
            
            // ... (rotation and movement logic)
            if (inputs.rotateLeft) mainCamera.rotateZ(CONFIG.torqueSpeed);
            if (inputs.rotateRight) mainCamera.rotateZ(-CONFIG.torqueSpeed);
            
            if (inputs.angUp) mainCamera.rotateX(CONFIG.angulationSpeed);
            if (inputs.angDown) mainCamera.rotateX(-CONFIG.angulationSpeed);
            if (inputs.angLeft) mainCamera.rotateY(CONFIG.angulationSpeed);
            if (inputs.angRight) mainCamera.rotateY(-CONFIG.angulationSpeed);

            if (isAdjustmentMode) {
                if(adjustmentInputs.xPlus) currentPos.x += speed; if(adjustmentInputs.xMinus) currentPos.x -= speed;
                if(adjustmentInputs.yPlus) currentPos.y += speed; if(adjustmentInputs.yMinus) currentPos.y -= speed;
                if(adjustmentInputs.zPlus) currentPos.z += speed; if(adjustmentInputs.zMinus) currentPos.z -= speed;
                coordDisplay.innerHTML = `ADJUST MODE<br>POS: ${currentPos.x.toFixed(2)}, ${currentPos.y.toFixed(2)}, ${currentPos.z.toFixed(2)}`;
            } else {
                const forwardDir = new THREE.Vector3();
                mainCamera.getWorldDirection(forwardDir);
                forwardDir.normalize();
                let moveVec = new THREE.Vector3(0,0,0);
                if (inputs.forward) moveVec.add(forwardDir);
                if (inputs.backward) moveVec.add(forwardDir.clone().negate());
                if (moveVec.lengthSq() > 0) {
                    moveVec.normalize().multiplyScalar(speed/5);
                    for(let i=0; i<5; i++) {
                        currentPos.add(moveVec);
                        if (!inputs.shift) currentPos.copy(resolveCollisions(currentPos));
                    }
                } else if (!inputs.shift) currentPos.copy(resolveCollisions(currentPos));
            }
                                                                        mainCamera.position.copy(currentPos);
                                                                        
                                                                        // Update Location Display (Based on insertion length)
                                                                        let currentLoc = LOCATIONS.ESOPHAGUS;
                                                                        if (insertDepth >= LOCATIONS.LARGE_INTESTINE.threshold) currentLoc = LOCATIONS.LARGE_INTESTINE;
                                                                        else if (insertDepth >= LOCATIONS.SMALL_INTESTINE.threshold) currentLoc = LOCATIONS.SMALL_INTESTINE;
                                                                        else if (insertDepth >= LOCATIONS.DUODENUM.threshold) currentLoc = LOCATIONS.DUODENUM;
                                                                        else if (insertDepth >= LOCATIONS.STOMACH_LOWER.threshold) currentLoc = LOCATIONS.STOMACH_LOWER;
                                                                        else if (insertDepth >= LOCATIONS.STOMACH_MID.threshold) currentLoc = LOCATIONS.STOMACH_MID;
                                                                        else if (insertDepth >= LOCATIONS.STOMACH_UPPER.threshold) currentLoc = LOCATIONS.STOMACH_UPPER;
                                                                        else currentLoc = LOCATIONS.ESOPHAGUS;
                                                            
                                                                        document.getElementById('location-display').innerText = `LOC: ${currentLoc.en} (${currentLoc.jp})`;
                                                            
                                                                                                document.getElementById('depth-indicator').innerHTML = `INSERT: ${insertDepth.toFixed(1)} cm<br>TRAVELED: ${totalDistance.toFixed(1)} cm`;
                                                                        // Update Trail and Distances
                                    const frameDist = currentPos.distanceTo(lastFramePos);
                                    // Ignore tiny jitter from collision resolution
                                    if (frameDist > 0.01) {
                                        const moveDir = currentPos.clone().sub(lastFramePos).normalize();
                                        const forwardDir = new THREE.Vector3();
                                        mainCamera.getWorldDirection(forwardDir);
                                        const dot = moveDir.dot(forwardDir);
                                        
                                        totalDistance += frameDist;
                                        insertDepth += frameDist * (dot > 0 ? 1 : -1);
                                        if (insertDepth < 0) insertDepth = 0;
                                    }
                                    lastFramePos.copy(currentPos);
                        
                                    // Update Minimap Trail (dots every 0.5cm)
                                    const trailDist = currentPos.distanceTo(lastTrailPos);
                                    if (trailDist > 0.5) {
                                        trailPoints.push(currentPos.x, currentPos.y, currentPos.z);
                                                        trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPoints, 3));
                                                        lastTrailPos.copy(currentPos);
                                                    }
                                        
                                                    // Lesion Detection
                                                    lesions.forEach(l => {
                                                        if(!l.found && currentPos.distanceTo(l.position) < 8) {
                                                            l.found = true;
                                                            const div = document.createElement('div'); 
                                                            div.style.color = '#ff3333'; 
                                                            div.innerText = `> LESION DETECTED (病変発見)`;
                                                            document.getElementById('pathology-log').appendChild(div);
                                                        }
                                                    });
                                        
                                                    playerGroup.position.copy(currentPos);
                                                    playerGroup.quaternion.copy(mainCamera.quaternion);
            mapControls.target.copy(currentPos);
            mapControls.update();

            lesions.forEach(l => {
                if(!l.found && currentPos.distanceTo(l.position) < 15) {
                    l.found = true;
                    const div = document.createElement('div'); div.style.color = '#ff3333'; div.innerText = `> LESION DETECTED`;
                    document.getElementById('pathology-log').appendChild(div);
                }
            });
        }

        function render() {
            requestAnimationFrame(render);
            update();
            scopeLight.intensity = 15.0 * state.exposure + Math.sin(Date.now() * 0.01) * 0.5;
            composer.render();
            mapRenderer.render(mapScene, mapCamera);
        }
        window.addEventListener('resize', () => {
            mainCamera.aspect = window.innerWidth/window.innerHeight; mainCamera.updateProjectionMatrix();
            mainRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Touch Logic
        function handleJoystick(elementId, callback) {
            const zone = document.getElementById(elementId);
            const knob = zone.querySelector('.touch-knob');
            let startX, startY;
            zone.addEventListener('touchstart', (e) => { e.preventDefault(); const t = e.changedTouches[0]; startX = t.clientX; startY = t.clientY; }, {passive: false});
            zone.addEventListener('touchmove', (e) => {
                e.preventDefault(); const t = e.changedTouches[0]; const dx = t.clientX - startX; const dy = t.clientY - startY;
                const dist = Math.min(40, Math.sqrt(dx*dx + dy*dy)); const angle = Math.atan2(dy, dx);
                knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                callback(dx / 40, dy / 40);
            }, {passive: false});
            zone.addEventListener('touchend', (e) => { e.preventDefault(); knob.style.transform = `translate(-50%, -50%)`; callback(0, 0); }, {passive: false});
        }
        handleJoystick('stick-left', (x, y) => {
            inputs.forward = y < -0.2; inputs.backward = y > 0.2;
            inputs.rotateRight = x > 0.2; inputs.rotateLeft = x < -0.2;
        });
        handleJoystick('stick-right', (x, y) => {
            inputs.angUp = y < -0.3; inputs.angDown = y > 0.3;
            inputs.angLeft = x < -0.3; inputs.angRight = x > 0.3;
        });
        document.getElementById('mobile-capture').addEventListener('touchstart', (e) => { e.preventDefault(); takePhoto(); });

        render();
    </script>
</body>
</html>
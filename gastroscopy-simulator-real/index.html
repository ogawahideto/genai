<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Gastroscopy Simulator v6.1 (Fixed Tracker)</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #minimap-container {
            position: absolute; bottom: 20px; right: 20px; width: 200px; height: 200px;
            border: 2px solid #00ffcc; background: #000; z-index: 50;
            border-radius: 4px; overflow: hidden; pointer-events: auto;
        }
        #minimap-label { position: absolute; top: 2px; left: 5px; color: #00ffcc; font-size: 10px; z-index: 52; font-weight: bold; font-family: monospace; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 10; pointer-events: none; }
        .osd-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #ui-controls { position: absolute; top: 120px; left: 20px; z-index: 30; font-family: 'Courier New', Courier, monospace; color: #00ffcc; font-size: 12px; pointer-events: auto; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 4px; }
        #brightness-slider { width: 80px; vertical-align: middle; cursor: pointer; }
        .btn-capture { margin-top: 10px; background: #ff3333; color: white; border: none; padding: 5px 10px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold; border-radius: 2px; width: 100%; }
        #gallery { position: absolute; top: 120px; right: 20px; width: 120px; z-index: 40; display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
        .gallery-item { width: 100%; border: 1px solid #00ffcc; cursor: pointer; transition: transform 0.2s; background: #000; }
        .gallery-label { color: #00ffcc; font-size: 10px; text-align: center; font-family: monospace; background: rgba(0,0,0,0.5); }
        #shutter-flash { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: white; z-index: 100; opacity: 0; pointer-events: none; }
        .flash-active { animation: flash-anim 0.3s ease-out; }
        @keyframes flash-anim { 0% { opacity: 1; } 100% { opacity: 0; } }
        
        /* Mobile Controls */
        .touch-zone {
            position: absolute; bottom: 20px; width: 120px; height: 120px;
            border: 2px solid rgba(0, 255, 204, 0.3); border-radius: 50%;
            background: rgba(0, 0, 0, 0.2); pointer-events: auto; touch-action: none;
            display: flex;
        }
        .touch-knob {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            background: rgba(0, 255, 204, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #stick-left { left: 20px; }
        #stick-right { right: 20px; }
        #mobile-capture {
            position: absolute; top: 120px; right: 20px; width: 60px; height: 60px;
            background: rgba(255, 51, 51, 0.8); border-radius: 50%; border: 2px solid white;
            color: white; font-weight: bold; display: none; pointer-events: auto;
            align-items: center; justify-content: center; font-family: monospace; cursor: pointer;
            z-index: 60;
        }

        #pathology-log { position: absolute; top: 220px; left: 20px; width: 250px; font-family: 'Courier New', monospace; color: #ff3333; z-index: 5; text-shadow: 1px 1px 0 #000; pointer-events: none; }
        #location-display { position: absolute; top: 90px; right: 20px; color: #ff9900; font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold; z-index: 5; text-shadow: 0 0 2px #f00; text-align: right; }
        #controls-display { position: absolute; top: 320px; left: 20px; color: rgba(0, 255, 204, 0.7); font-family: 'Courier New', monospace; font-size: 10px; z-index: 5; pointer-events: none; }

        @media (max-width: 768px) {
            #mobile-capture { display: flex; }
            #ui-controls, #gallery, #controls-display { display: none; }
            #minimap-container { top: 10px; left: 10px; bottom: auto; right: auto; width: 100px; height: 100px; }
            #location-display { font-size: 12px; top: 10px; right: 10px; }
            #pathology-log { top: 50px; left: 10px; font-size: 10px; }
            #depth-indicator { font-size: 12px; margin-right: 10px !important; bottom: 150px; right: 10px; position: absolute;}
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="minimap-container"><div id="minimap-label">POS TRACKER</div></div>
    <div id="shutter-flash"></div>

    <div id="stick-left" class="touch-zone"><div class="touch-knob"></div></div>
    <div id="stick-right" class="touch-zone"><div class="touch-knob"></div></div>
    <div id="mobile-capture">SNAP</div>

    <div id="ui-overlay">
        <div class="monitor-mask"></div>
        <div class="osd-layer">
            <div class="osd-top-left">
                <div class="patient-info"><span class="label">NAME:</span> GEMINI, DUMMY<br><span class="label">ID:</span> 2026-0131-X<br><span class="label">DOB:</span> 1990/01/01<br><span class="label">SEX:</span> M</div>
            </div>
            <div id="ui-controls">BRIGHTNESS: <input type="range" id="brightness-slider" min="0.5" max="5.0" step="0.1" value="1.5"><br><button class="btn-capture" id="btn-capture">PHOTO [P]</button></div>
            <div id="gallery"><div class="gallery-label">CAPTURES</div></div>
            <div id="pathology-log"><strong>[PATHOLOGY LOG]</strong><br></div>
            <div class="osd-top-right"><div class="hospital-info">GEMINI GEN AI CLINIC<br>GIF-H290Z</div><div id="timestamp">--:--:--</div></div>
            <div id="location-display">LOC: ESOPHAGUS</div>
            <div id="controls-display">[CONTROLS]<br><strong>W / S</strong> : Insert/Back<br><strong>Arrows</strong>: Angulation (Turn)<br><strong>Shift+W</strong>: Force Move<br><strong>M</strong>: Adjust Mode</div>
            <div class="osd-bottom-left"><div class="scope-status"><span class="label">ENHANCE:</span> A1<br><span class="label">IRIS:</span> AUTO</div></div>
            <div class="osd-bottom-right"><div id="depth-indicator" style="margin-right: 210px;">INSERT: 0 cm</div></div>
        </div>
        <div class="scanlines"></div><div class="noise"></div>
    </div>

    <div id="instructions">
        <h2>GASTROSCOPY SIMULATOR V6.1</h2>
        <p id="loading-status" style="color: cyan; margin-top: 20px;">LOADING MODEL...</p>
        <p id="start-btn" style="color: yellow; margin-top: 20px; cursor: pointer; border: 1px solid yellow; padding: 10px; display: none;">CLICK TO START</p>
        <p id="error-msg" style="color: red; margin-top: 20px; display: none;">ERROR: Model failed to load.</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/loaders/GLTFLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js",
                "three/addons/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const CONFIG = { moveSpeed: 0.0003, torqueSpeed: 0.03, angulationSpeed: 0.04 };
        const state = { progress: 0.015, torque: 0, angulation: new THREE.Vector2(0, 0), roll: 0, exposure: 1.5 };
        const inputs = { forward: false, backward: false, rotateLeft: false, rotateRight: false, angUp: false, angDown: false, angLeft: false, angRight: false, shift: false };

        // Globals
        let stomachModel = null;
        const lesions = [];
        const raycaster = new THREE.Raycaster();
        const loader = new GLTFLoader();

        // Main Scene
        const mainRenderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        mainRenderer.setSize(window.innerWidth, window.innerHeight);
        mainRenderer.toneMapping = THREE.ACESFilmicToneMapping;
        mainRenderer.toneMappingExposure = state.exposure;
        document.getElementById('canvas-container').appendChild(mainRenderer.domElement);
        
        const mainScene = new THREE.Scene(); mainScene.fog = new THREE.FogExp2(0x1a0505, 0.002);
        const mainCamera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.05, 1000);

        // Minimap
        const mapRenderer = new THREE.WebGLRenderer({ antialias: true });
        mapRenderer.setSize(200, 200);
        document.getElementById('minimap-container').appendChild(mapRenderer.domElement);
        const mapScene = new THREE.Scene(); mapScene.background = new THREE.Color(0x000000); 
        const mapCamera = new THREE.PerspectiveCamera(45, 1, 10, 1000);
        mapCamera.position.set(200, 50, 200); 
        const mapControls = new OrbitControls(mapCamera, mapRenderer.domElement);
        mapControls.enableDamping = true;
        mapControls.dampingFactor = 0.05;

        // Player Marker Group
        const playerMarker = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshBasicMaterial({color: 0xff0000}));
        const directionCone = new THREE.Mesh(new THREE.ConeGeometry(1, 5, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        directionCone.position.z = -3; directionCone.rotation.x = -Math.PI / 2;
        const playerGroup = new THREE.Group();
        playerGroup.add(playerMarker); playerGroup.add(directionCone);
        mapScene.add(playerGroup);

        // Load Model
        loader.load('realistic_human_stomach.glb', (gltf) => {
            stomachModel = gltf.scene;
            const box = new THREE.Box3().setFromObject(stomachModel);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            stomachModel.position.set(-center.x, -box.max.y, -center.z);
            const desiredHeight = 200;
            const scaleFactor = desiredHeight / size.y;
            if (size.y < 50 || size.y > 500) stomachModel.scale.multiplyScalar(scaleFactor);

            stomachModel.traverse((child) => {
                if (child.isMesh) {
                    const oldMat = child.material;
                    child.material = new THREE.MeshPhysicalMaterial({
                        color: oldMat.color || 0xffaaaa,
                        map: oldMat.map || null,
                        normalMap: oldMat.normalMap || null,
                        roughness: 0.15,
                        metalness: 0.05,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.05,
                        reflectivity: 0.5,
                        side: THREE.DoubleSide
                    });
                }
            });
            mainScene.add(stomachModel);
            
            // Lesions
            const tempRay = new THREE.Raycaster();
            for(let i=0; i<15; i++) {
                for(let a=0; a<10; a++) {
                    const origin = new THREE.Vector3((Math.random()-0.5)*size.x*scaleFactor, (Math.random()-0.5)*size.y*scaleFactor-100, (Math.random()-0.5)*size.z*scaleFactor);
                    const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                    tempRay.set(origin, dir);
                    const hits = tempRay.intersectObject(stomachModel, true);
                    if(hits.length > 0) {
                        const hit = hits[0];
                        const lmesh = new THREE.Mesh(new THREE.SphereGeometry(2,16,16,0,Math.PI*2,0,Math.PI*0.7), new THREE.MeshPhysicalMaterial({color:0xcc0000, roughness:0.1, clearcoat:1.0}));
                        lmesh.position.copy(hit.point);
                        lmesh.lookAt(hit.point.clone().add(hit.face.normal.clone().applyQuaternion(hit.object.quaternion)));
                        mainScene.add(lmesh);
                        lesions.push({ mesh: lmesh, found: false, position: hit.point });
                        break;
                    }
                }
            }

            const mapModel = stomachModel.clone();
            mapModel.traverse(c => { if(c.isMesh) c.material = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true, transparent:true, opacity:0.3}); });
            mapScene.add(mapModel);
            
            document.getElementById('loading-status').style.display = 'none';
            document.getElementById('start-btn').style.display = 'inline-block';
        }, undefined, (err) => {
            console.error(err);
            document.getElementById('loading-status').style.display = 'none';
            document.getElementById('error-msg').style.display = 'block';
        });

        // Controls
        const manualControl = { x: 0.5, y: 194, z: -10.5 }; 
        const currentPos = new THREE.Vector3(manualControl.x, manualControl.y, manualControl.z);
        let isAdjustmentMode = false;
        const adjustmentInputs = { xPlus: false, xMinus: false, yPlus: false, yMinus: false, zPlus: false, zMinus: false };
        let coordDisplay = document.getElementById('coord-display') || document.createElement('div');
        if(!coordDisplay.parentNode) {
            coordDisplay.id = 'coord-display';
            coordDisplay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: lime; font-family: monospace; font-size: 20px; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid lime; display: none; z-index: 1000;';
            document.body.appendChild(coordDisplay);
        }

        const hemiLight = new THREE.HemisphereLight( 0xffaaaa, 0x440000, 0.5 );
        mainScene.add( hemiLight );
        const scopeLight = new THREE.SpotLight(0xfff0e0, 15.0, 80, 0.7, 0.5, 1.5);
        mainCamera.add(scopeLight); mainCamera.add(scopeLight.target); mainScene.add(mainCamera);
        scopeLight.target.position.set(0, 0, -1);

        // Interaction Listeners
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(e.shiftKey) inputs.shift = true;
            if (k === 'm') { isAdjustmentMode = !isAdjustmentMode; coordDisplay.style.display = isAdjustmentMode ? 'block' : 'none'; }
            if(k==='w') inputs.forward=true; if(k==='s') inputs.backward=true;
            if(k==='a') inputs.rotateLeft=true; if(k==='d') inputs.rotateRight=true;
            if(k==='arrowup') inputs.angUp=true; if(k==='arrowdown') inputs.angDown=true;
            if(k==='arrowleft') inputs.angLeft=true; if(k==='arrowright') inputs.angRight=true;
            if(k==='p' || e.key==='Enter') takePhoto();
            if (isAdjustmentMode) {
                if(k==='i') adjustmentInputs.yPlus = true; if(k==='k') adjustmentInputs.yMinus = true;
                if(k==='j') adjustmentInputs.xMinus = true; if(k==='l') adjustmentInputs.xPlus = true;
                if(k==='u') adjustmentInputs.zMinus = true; if(k==='o') adjustmentInputs.zPlus = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(!e.shiftKey) inputs.shift = false;
            if(k==='w') inputs.forward=false; if(k==='s') inputs.backward=false;
            if(k==='a') inputs.rotateLeft=false; if(k==='d') inputs.rotateRight=false;
            if(k==='arrowup') inputs.angUp=false; if(k==='arrowdown') inputs.angDown=false;
            if(k==='arrowleft') inputs.angLeft=false; if(k==='arrowright') inputs.angRight=false;
            if (isAdjustmentMode) {
                if(k==='i') adjustmentInputs.yPlus = false; if(k==='k') adjustmentInputs.yMinus = false;
                if(k==='j') adjustmentInputs.xMinus = false; if(k==='l') adjustmentInputs.xPlus = false;
                if(k==='u') adjustmentInputs.zMinus = false; if(k==='o') adjustmentInputs.zPlus = false;
            }
        });

        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            state.exposure = parseFloat(e.target.value);
            mainRenderer.toneMappingExposure = state.exposure;
        });
        document.getElementById('start-btn').onclick = function() { document.getElementById('instructions').style.display = 'none'; };

        const takePhoto = () => {
            const flash = document.getElementById('shutter-flash');
            flash.classList.remove('flash-active'); void flash.offsetWidth; flash.classList.add('flash-active');
            const dataUrl = mainRenderer.domElement.toDataURL("image/png");
            const gallery = document.getElementById('gallery');
            const img = document.createElement('img');
            img.src = dataUrl; img.className = 'gallery-item';
            img.onclick = () => { const link = document.createElement('a'); link.download = `gastroscopy_${new Date().getTime()}.png`; link.href = dataUrl; link.click(); };
            gallery.insertBefore(img, gallery.children[1]);
        };

        // Collision Logic
        const OUTER_RADIUS = 1.5;
        const INNER_RADIUS = 0.4;
        function resolveCollisions(position) {
            if (!stomachModel) return position;
            const dirs = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)];
            let adjustedPos = position.clone();
            for(let dir of dirs) {
                raycaster.set(adjustedPos, dir);
                const hits = raycaster.intersectObject(stomachModel, true);
                if (hits.length > 0) {
                    const hit = hits[0];
                    let n = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                    if (n.dot(dir) > 0) n.negate();
                    if (hit.distance < INNER_RADIUS) adjustedPos.add(n.multiplyScalar(INNER_RADIUS - hit.distance));
                    else if (hit.distance < OUTER_RADIUS) adjustedPos.add(n.multiplyScalar((OUTER_RADIUS - hit.distance) * 0.1));
                }
            }
            return adjustedPos;
        }

        function update() {
            const speed = 0.5;
            if (inputs.rotateLeft) state.torque += CONFIG.torqueSpeed;
            if (inputs.rotateRight) state.torque -= CONFIG.torqueSpeed;
            state.torque *= 0.9;
            if (inputs.angUp) state.angulation.y += CONFIG.angulationSpeed;
            if (inputs.angDown) state.angulation.y -= CONFIG.angulationSpeed;
            if (inputs.angLeft) state.angulation.x -= CONFIG.angulationSpeed;
            if (inputs.angRight) state.angulation.x += CONFIG.angulationSpeed;
            state.angulation.x = Math.max(-2.5, Math.min(2.5, state.angulation.x));
            state.angulation.y = Math.max(-2.5, Math.min(2.5, state.angulation.y));
            state.angulation.x *= 0.98; state.angulation.y *= 0.98;

            mainCamera.rotation.set(0, 0, 0); 
            mainCamera.rotateX(-Math.PI / 2);
            if (!state.roll) state.roll = 0; state.roll += state.torque;
            mainCamera.rotateZ(state.roll);
            mainCamera.rotateX(state.angulation.y);
            mainCamera.rotateY(-state.angulation.x);
            mainCamera.updateMatrixWorld(); 

            if (isAdjustmentMode) {
                if(adjustmentInputs.xPlus) currentPos.x += speed; if(adjustmentInputs.xMinus) currentPos.x -= speed;
                if(adjustmentInputs.yPlus) currentPos.y += speed; if(adjustmentInputs.yMinus) currentPos.y -= speed;
                if(adjustmentInputs.zPlus) currentPos.z += speed; if(adjustmentInputs.zMinus) currentPos.z -= speed;
                coordDisplay.innerHTML = `ADJUST MODE<br>POS: ${currentPos.x.toFixed(2)}, ${currentPos.y.toFixed(2)}, ${currentPos.z.toFixed(2)}`;
            } else {
                const forwardDir = new THREE.Vector3();
                mainCamera.getWorldDirection(forwardDir);
                forwardDir.normalize();
                let moveVec = new THREE.Vector3(0,0,0);
                if (inputs.forward) moveVec.add(forwardDir);
                if (inputs.backward) moveVec.add(forwardDir.clone().negate());
                if (moveVec.lengthSq() > 0) {
                    moveVec.normalize().multiplyScalar(speed/5);
                    for(let i=0; i<5; i++) {
                        currentPos.add(moveVec);
                        if (!inputs.shift) currentPos.copy(resolveCollisions(currentPos));
                    }
                } else if (!inputs.shift) currentPos.copy(resolveCollisions(currentPos));
            }
            mainCamera.position.copy(currentPos);
            document.getElementById('depth-indicator').innerText = `INSERT: ${(194 - currentPos.y).toFixed(1)} cm`;
            playerGroup.position.copy(currentPos);
            playerGroup.quaternion.copy(mainCamera.quaternion);
            mapControls.target.copy(currentPos);
            mapControls.update();

            lesions.forEach(l => {
                if(!l.found && currentPos.distanceTo(l.position) < 15) {
                    l.found = true;
                    const div = document.createElement('div'); div.style.color = '#ff3333'; div.innerText = `> LESION DETECTED`;
                    document.getElementById('pathology-log').appendChild(div);
                }
            });
        }

        function render() {
            requestAnimationFrame(render);
            update();
            scopeLight.intensity = 15.0 * state.exposure + Math.sin(Date.now() * 0.01) * 0.5;
            mainRenderer.render(mainScene, mainCamera);
            mapRenderer.render(mapScene, mapCamera);
        }
        window.addEventListener('resize', () => {
            mainCamera.aspect = window.innerWidth/window.innerHeight; mainCamera.updateProjectionMatrix();
            mainRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Touch Logic
        function handleJoystick(elementId, callback) {
            const zone = document.getElementById(elementId);
            const knob = zone.querySelector('.touch-knob');
            let startX, startY;
            zone.addEventListener('touchstart', (e) => { e.preventDefault(); const t = e.changedTouches[0]; startX = t.clientX; startY = t.clientY; }, {passive: false});
            zone.addEventListener('touchmove', (e) => {
                e.preventDefault(); const t = e.changedTouches[0]; const dx = t.clientX - startX; const dy = t.clientY - startY;
                const dist = Math.min(40, Math.sqrt(dx*dx + dy*dy)); const angle = Math.atan2(dy, dx);
                knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                callback(dx / 40, dy / 40);
            }, {passive: false});
            zone.addEventListener('touchend', (e) => { e.preventDefault(); knob.style.transform = `translate(-50%, -50%)`; callback(0, 0); }, {passive: false});
        }
        handleJoystick('stick-left', (x, y) => {
            inputs.forward = y < -0.2; inputs.backward = y > 0.2;
            inputs.rotateRight = x > 0.2; inputs.rotateLeft = x < -0.2;
        });
        handleJoystick('stick-right', (x, y) => {
            inputs.angUp = y < -0.3; inputs.angDown = y > 0.3;
            inputs.angLeft = x < -0.3; inputs.angRight = x > 0.3;
        });
        document.getElementById('mobile-capture').addEventListener('touchstart', (e) => { e.preventDefault(); takePhoto(); });

        render();
    </script>
</body>
</html>
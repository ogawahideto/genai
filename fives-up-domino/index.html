
<!--
AIモデル: Gemini
作成日時: 2025-11-30
ユーザープロンプト: domino-gameをベースにfives upルールのゲームを作ってください。別のフォルダに作ってください。
AIのアプローチ:
- HTML, CSS, JavaScriptを単一の`index.html`ファイルに記述するシングルファイルアーキテクチャを採用。
- 外部ライブラリは使用せず、標準的なWeb APIのみで実装。
- Fives Upルールに基づき、ボードのオープンな両端の合計が5の倍数になった場合に得点するロジックを実装。
- ダブル牌は横向きに表示するように変更。
- スピンナー（4方向接続）のロジックは、既存のデータ構造と複雑に絡むため、今回は見送り、両端の合計点のみでFives Upルールを実装する。
- 既存のドミノゲームのコードベースを最大限に活用し、差分でFives Upルールを実装。
実装の意図:
- 既存のドミノゲームをベースに、Fives Upルールという異なるゲーム体験を提供する。
- AIとの共同開発プロセスを通じて、新しいゲームを効率的に作成する。
-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fives Up ドミノ</title>
    <style>
        :root {
            --domino-width: 40px;
            --domino-height: 80px;
            --dot-size: 8px;
            --board-color: #006400;
            --domino-color: #f8f8f8;
            --dot-color: #333;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 1em;
            height: 100vh;
            box-sizing: border-box;
        }
        h1 {
            color: #333;
        }
        .game-container {
            display: grid;
            grid-template-areas:
                "computer-hand"
                "board"
                "player-hand";
            grid-template-rows: 120px 1fr 120px;
            width: 100%;
            height: calc(100vh - 150px);
            max-width: 1200px;
            gap: 1em;
        }
        .hand {
            padding: 10px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        #computer-hand { grid-area: computer-hand; }
        #player-hand { grid-area: player-hand; }
        #game-board {
            grid-area: board;
            background-color: var(--board-color);
            border: 5px solid saddlebrown;
            border-radius: 10px;
            padding: 20px;
            overflow: visible; /* Allow content to go beyond bounds for spinner branches */
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* Left branch, spinner column, right branch */
            grid-template-rows: auto auto auto; /* Up branch, spinner row, down branch */
            justify-items: center;
            align-items: center;
            position: relative; /* For absolute positioning of some elements if needed */
        }
        .main-board-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* Left chain, spinner column, right chain */
            grid-template-rows: auto auto auto; /* Up chain, spinner row, down chain */
            justify-items: center;
            align-items: center;
            width: 100%;
            height: 100%;
            overflow: visible; /* Allow content to go beyond bounds for spinner branches */
        }

        .main-horizontal-chain {
            grid-column: 1 / span 3; /* Spans across all three columns when no spinner */
            grid-row: 2; /* Center row */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: auto;
            min-height: var(--domino-height);
        }

        .left-main-chain-container,
        .right-main-chain-container {
            display: flex;
            align-items: center;
            grid-row: 2; /* Main horizontal row */
        }
        .left-main-chain-container {
            grid-column: 1;
            justify-content: flex-end; /* Align to the right side of its cell */
        }
        .right-main-chain-container {
            grid-column: 3;
            justify-content: flex-start; /* Align to the left side of its cell */
        }

        .spinner-node {
            grid-column: 2; /* Center column */
            grid-row: 1 / span 3; /* Spans all three rows */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .spinner-central-node { /* Container for spinner + up/down branches */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .spinner-branch-up,
        .spinner-branch-down {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .spinner-branch-up {
            flex-direction: column-reverse; /* Stack dominoes upwards */
        }

        .domino {
            width: var(--domino-width);
            height: var(--domino-height);
            background-color: var(--domino-color);
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            padding: 4px;
            box-sizing: border-box;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s;
            position: relative;
            flex-shrink: 0;
        }
        .domino.horizontal {
            width: var(--domino-height);
            height: var(--domino-width);
            flex-direction: row;
        }
        .domino-half {
            flex: 1;
            display: grid;
            place-items: center;
            position: relative;
            padding: 2px;
        }
        .domino.horizontal .domino-half {
            border-top: none;
            border-right: 1px solid #ccc;
        }
        .domino.horizontal .domino-half:last-child {
            border-right: none;
        }
        .domino:not(.horizontal) .domino-half {
             border-bottom: 1px solid #ccc;
        }
         .domino:not(.horizontal) .domino-half:last-child {
             border-bottom: none;
        }
        .dot {
            width: var(--dot-size);
            height: var(--dot-size);
            background-color: var(--dot-color);
            border-radius: 50%;
            position: absolute;
        }
        #player-hand .domino:hover {
            transform: translateY(-10px);
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .domino.back {
            background-color: #555;
            background-image: repeating-linear-gradient(45deg, #666 0, #666 10px, #555 10px, #555 20px);
        }
        #game-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: right;
        }
        #stock-info, #score-info {
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        #message-area {
            font-size: 1.2em;
            color: firebrick;
            font-weight: bold;
            min-height: 25px;
        }
        .play-area {
            width: 50px;
            height: 90px;
            border: 2px dashed #fff5;
            border-radius: 8px;
            transition: background-color 0.2s;
            flex-shrink: 0;
        }
        .play-area.horizontal {
             width: 90px;
             height: 50px;
        }
        .play-area.vertical {
            width: 50px; /* Same as default domino width */
            height: 90px; /* Same as default domino height */
        }
        .play-area.highlight {
            background-color: rgba(255, 255, 0, 0.5);
            cursor: pointer;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            text-align: center;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-content h2 {
            margin-top: 0;
        }
    </style>
</head>
<body>

    <h1>Fives Up ドミノ</h1>

    <div class="game-container">
        <div id="computer-hand" class="hand"></div>
        <div id="game-board"></div>
        <div id="player-hand" class="hand"></div>
    </div>

    <div id="game-info">
        <div id="score-info">スコア: あなた 0 - 0 CPU</div>
        <div id="stock-info">山札: 14</div>
        <div id="message-area"></div>
        <button id="pass-button" style="display: none;">パス / 山から引く</button>
        <button id="restart-button" style="display: none;">次のラウンド</button>
    </div>
    
    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 id="game-over-title"></h2>
            <p id="game-over-text"></p>
            <button id="new-game-button">新しいゲームを始める</button>
        </div>
    </div>


    <script>
    const playerHandElem = document.getElementById('player-hand');
    const computerHandElem = document.getElementById('computer-hand');
    const gameBoardElem = document.getElementById('game-board');
    const stockInfoElem = document.getElementById('stock-info');
    const scoreInfoElem = document.getElementById('score-info');
    const messageAreaElem = document.getElementById('message-area');
    const passButton = document.getElementById('pass-button');
    const restartButton = document.getElementById('restart-button');
    const gameOverModal = document.getElementById('game-over-modal');
    const gameOverTitle = document.getElementById('game-over-title');
    const gameOverText = document.getElementById('game-over-text');
    const newGameButton = document.getElementById('new-game-button');

    const MAX_SCORE = 100;

    let stock = [];
    let playerHand = [];
    let computerHand = [];
    let board = { main: [], up: [], down: [] };
    let playableEnds = [];
    
    let scores = { player: 0, computer: 0 };
    let currentPlayer = 'player';
    let selectedDomino = { element: null, domino: null, index: -1 };

    function createDominoes() {
        const dominoes = [];
        for (let i = 0; i <= 6; i++) {
            for (let j = i; j <= 6; j++) {
                dominoes.push({ a: i, b: j, isDouble: i === j });
            }
        }
        return dominoes;
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function startGame() {
        scores = { player: 0, computer: 0 };
        startRound();
    }
    
    function startRound() {
        // Reset game state
        stock = createDominoes();
        shuffle(stock);

        playerHand = stock.splice(0, 7);
        computerHand = stock.splice(0, 7);
        board = { main: [], up: [], down: [] };
        playableEnds = [];
        
        // Decide who starts
        const playerMaxDouble = Math.max(...playerHand.filter(d => d.isDouble).map(d => d.a), -1);
        const computerMaxDouble = Math.max(...computerHand.filter(d => d.isDouble).map(d => d.a), -1);

        if (playerMaxDouble === -1 && computerMaxDouble === -1) {
            const playerMax = Math.max(...playerHand.map(d => d.a + d.b));
            const computerMax = Math.max(...computerHand.map(d => d.a + d.b));
            currentPlayer = playerMax >= computerMax ? 'player' : 'computer';
        } else {
            currentPlayer = playerMaxDouble >= computerMaxDouble ? 'player' : 'computer';
        }

        updateUI();
        restartButton.style.display = 'none';

        if (currentPlayer === 'computer') {
            setMessage('コンピュータのターンです...');
            setTimeout(computerTurn, 1000);
        } else {
            setMessage('あなたのターンです。');
            checkPlayerMoves();
        }
    }
    
    function createDominoElement(dominoPiece, isBack = false) {
        const div = document.createElement('div');
        div.className = 'domino';
        if (isBack) {
            div.classList.add('back');
            return div;
        }
        
        const { domino, displayA, displayB, horizontal } = dominoPiece;

        div.dataset.a = domino.a;
        div.dataset.b = domino.b;

        if (horizontal) {
            div.classList.add('horizontal');
        }

        const halfA = createHalf(displayA);
        const halfB = createHalf(displayB);
        div.appendChild(halfA);
        div.appendChild(halfB);
        return div;
    }

    function createHalf(number) {
        const half = document.createElement('div');
        half.className = 'domino-half';
        half.dataset.value = number;
        
        const positions = [
            [], // 0
            [[50, 50]], // 1
            [[25, 25], [75, 75]], // 2
            [[25, 25], [50, 50], [75, 75]], // 3
            [[25, 25], [25, 75], [75, 25], [75, 75]], // 4
            [[25, 25], [25, 75], [75, 25], [75, 75], [50, 50]], // 5
            [[25, 25], [25, 75], [50, 25], [50, 75], [75, 25], [75, 75]] // 6
        ];

        if (number > 0) {
             positions[number].forEach(pos => {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.style.left = `${pos[0]}%`;
                dot.style.top = `${pos[1]}%`;
                dot.style.transform = 'translate(-50%, -50%)';
                half.appendChild(dot);
             });
        }
        return half;
    }

    function updateUI() {
        // Player Hand
        playerHandElem.innerHTML = '';
        playerHand.sort((x,y) => (x.a+x.b) - (y.a+y.b)).forEach((d, i) => {
            const dominoElem = createDominoElement({ domino: d, displayA: d.a, displayB: d.b, horizontal: false });
            dominoElem.addEventListener('click', () => onPlayerDominoClick(dominoElem, d, i));
            playerHandElem.appendChild(dominoElem);
        });

        // Computer Hand
        computerHandElem.innerHTML = '';
        computerHand.forEach(() => {
            computerHandElem.appendChild(createDominoElement(null, true));
        });

        // Board
        renderBoard();

        // Info
        stockInfoElem.textContent = `山札: ${stock.length}`;
        scoreInfoElem.textContent = `スコア: あなた ${scores.player} - ${scores.computer} CPU`;
    }
    
    function renderBoard() {
        gameBoardElem.innerHTML = ''; // Clear the board
        gameBoardElem.classList.add('main-board-grid'); // Ensure grid display for branches

        // Find spinner domino (if any)
        const spinnerDominoPiece = board.main.find(p => p.isSpinner);
        const spinnerIndexInMain = board.main.findIndex(p => p.isSpinner);

        if (!spinnerDominoPiece) {
            // No spinner yet, render as a single horizontal chain
            const mainChainContainer = document.createElement('div');
            mainChainContainer.className = 'domino-chain main-horizontal-chain';
            mainChainContainer.style.gridColumn = '1 / span 3'; // Span full width for non-spinner
            mainChainContainer.style.gridRow = '2';
            gameBoardElem.appendChild(mainChainContainer);

            // Add left play area
            const leftEnd = playableEnds.find(end => end.type === 'left');
            if (leftEnd) {
                const playAreaIndex = playableEnds.indexOf(leftEnd);
                const playArea = createPlayArea(leftEnd.type, playAreaIndex);
                playArea.classList.add('horizontal');
                mainChainContainer.appendChild(playArea);
            }

            // Render existing dominoes from board.main
            board.main.forEach(d => {
                const dominoElem = createDominoElement(d);
                mainChainContainer.appendChild(dominoElem);
            });

            // Add right play area
            const rightEnd = playableEnds.find(end => end.type === 'right');
            if (rightEnd) {
                const playAreaIndex = playableEnds.indexOf(rightEnd);
                const playArea = createPlayArea(rightEnd.type, playAreaIndex);
                playArea.classList.add('horizontal');
                mainChainContainer.appendChild(playArea);
            }

        } else {
            // Spinner exists, render with branches
            // Left Main Chain Container
            const leftMainChainContainer = document.createElement('div');
            leftMainChainContainer.className = 'domino-chain left-main-chain-container';
            leftMainChainContainer.style.gridColumn = '1';
            leftMainChainContainer.style.gridRow = '2';
            leftMainChainContainer.style.display = 'flex';
            leftMainChainContainer.style.alignItems = 'center';
            leftMainChainContainer.style.justifyContent = 'flex-end';
            gameBoardElem.appendChild(leftMainChainContainer);
            
            // Left Play Area for main chain
            const leftEnd = playableEnds.find(end => end.type === 'left');
            if (leftEnd) {
                const playAreaIndex = playableEnds.indexOf(leftEnd);
                const playArea = createPlayArea(leftEnd.type, playAreaIndex);
                playArea.classList.add('horizontal');
                leftMainChainContainer.appendChild(playArea);
            }
            // Dominoes before spinner
            for (let i = spinnerIndexInMain - 1; i >= 0; i--) { // Render in reverse for left-to-right visual flow
                leftMainChainContainer.appendChild(createDominoElement(board.main[i]));
            }


            // Spinner Node (Center)
            const spinnerNode = document.createElement('div');
            spinnerNode.className = 'spinner-node';
            spinnerNode.style.gridColumn = '2';
            spinnerNode.style.gridRow = '1 / span 3'; // Spans full height for vertical branches
            spinnerNode.style.display = 'flex';
            spinnerNode.style.flexDirection = 'column';
            spinnerNode.style.alignItems = 'center';
            gameBoardElem.appendChild(spinnerNode);

            // Up Branch Container
            const upBranchContainer = document.createElement('div');
            upBranchContainer.className = 'domino-chain up-branch-container';
            upBranchContainer.style.flexDirection = 'column-reverse'; // To stack dominoes upwards
            upBranchContainer.style.alignItems = 'center';
            spinnerNode.appendChild(upBranchContainer);
            // Up Play Area
            const upEnd = playableEnds.find(end => end.type === 'up');
            if (upEnd) {
                const playAreaIndex = playableEnds.indexOf(upEnd);
                const playArea = createPlayArea(upEnd.type, playAreaIndex);
                playArea.classList.add('vertical');
                upBranchContainer.appendChild(playArea);
            }
            // Dominoes in up chain
            board.up.reverse().forEach(d => upBranchContainer.appendChild(createDominoElement(d)));


            // Spinner itself
            spinnerNode.appendChild(createDominoElement(spinnerDominoPiece));

            // Down Branch Container
            const downBranchContainer = document.createElement('div');
            downBranchContainer.className = 'domino-chain down-branch-container';
            downBranchContainer.style.flexDirection = 'column'; // To stack dominoes downwards
            downBranchContainer.style.alignItems = 'center';
            spinnerNode.appendChild(downBranchContainer);
            // Dominoes in down chain
            board.down.forEach(d => downBranchContainer.appendChild(createDominoElement(d)));
            // Down Play Area
            const downEnd = playableEnds.find(end => end.type === 'down');
            if (downEnd) {
                const playAreaIndex = playableEnds.indexOf(downEnd);
                const playArea = createPlayArea(downEnd.type, playAreaIndex);
                playArea.classList.add('vertical');
                downBranchContainer.appendChild(playArea);
            }


            // Right Main Chain Container
            const rightMainChainContainer = document.createElement('div');
            rightMainChainContainer.className = 'domino-chain right-main-chain-container';
            rightMainChainContainer.style.gridColumn = '3';
            rightMainChainContainer.style.gridRow = '2';
            rightMainChainContainer.style.display = 'flex';
            rightMainChainContainer.style.alignItems = 'center';
            rightMainChainContainer.style.justifyContent = 'flex-start';
            gameBoardElem.appendChild(rightMainChainContainer);
            // Dominoes after spinner
            for (let i = spinnerIndexInMain + 1; i < board.main.length; i++) {
                rightMainChainContainer.appendChild(createDominoElement(board.main[i]));
            }
            // Right Play Area for main chain
            const rightEnd = playableEnds.find(end => end.type === 'right');
            if (rightEnd) {
                const playAreaIndex = playableEnds.indexOf(rightEnd);
                const playArea = createPlayArea(rightEnd.type, playAreaIndex);
                playArea.classList.add('horizontal');
                rightMainChainContainer.appendChild(playArea);
            }
        }
        
        if (selectedDomino.domino) {
            highlightPlayAreas();
        }
    }
    
    function createPlayArea(endType, endIndex) {
        const area = document.createElement('div');
        area.className = 'play-area';
        area.dataset.type = endType;
        area.dataset.endIndex = endIndex;
        area.addEventListener('click', () => onPlayAreaClick(endIndex)); // Pass the index
        return area;
    }

    function onPlayerDominoClick(element, domino, index) {
        if (currentPlayer !== 'player') return;

        if (selectedDomino.element) {
            selectedDomino.element.style.transform = '';
        }
        if (selectedDomino.element === element) {
            selectedDomino = { element: null, domino: null, index: -1 };
            clearHighlights();
        } else {
            selectedDomino = { element, domino, index };
            element.style.transform = 'translateY(-10px) scale(1.05)';
            highlightPlayAreas();
        }
    }
    
    function highlightPlayAreas() {
        clearHighlights();
        if (!selectedDomino.domino) return;
        
        const { a, b } = selectedDomino.domino;
        
        if (board.length === 0) {
            // If board is empty, any domino can be played on any initial play area
            // All play areas generated by renderBoard should be highlighted
            document.querySelectorAll('.play-area').forEach(area => area.classList.add('highlight'));
            return;
        }

        playableEnds.forEach((end, index) => {
            if (a === end.value || b === end.value) {
                // Find the specific play area element to highlight using data-end-index
                const playAreaElement = document.querySelector(`.play-area[data-end-index="${index}"]`);
                if (playAreaElement) {
                    playAreaElement.classList.add('highlight');
                }
            }
        });
    }
    
    function clearHighlights() {
        document.querySelectorAll('.play-area').forEach(a => a.classList.remove('highlight'));
    }

    function onPlayAreaClick(endIndex) { // Now receives the index of the playable end
        if (currentPlayer !== 'player' || !selectedDomino.domino) return;

        const selectedPlayableEnd = playableEnds[endIndex];
        if (!selectedPlayableEnd) { // Defensive check
            console.error("Playable end not found for index:", endIndex);
            return;
        }

        // Check if selectedDomino can actually be played on this end
        const { a, b } = selectedDomino.domino;
        const endValue = selectedPlayableEnd.value;

        if (!(a === endValue || b === endValue)) {
            setMessage("ここには置けません。");
            return;
        }
        
        placeDomino(selectedDomino.index, endIndex); // Pass index of selected playable end
    }
    
    function placeDomino(handIndex, selectedEndIndex) {
        const domino = (currentPlayer === 'player' ? playerHand : computerHand)[handIndex];
        
        let pieceData = { domino: domino, displayA: domino.a, displayB: domino.b, horizontal: false, isSpinner: false };

        if (board.main.length === 0 && board.up.length === 0 && board.down.length === 0) {
            // First domino placed (always vertical for simplicity)
            pieceData.horizontal = false; 
            board.main.push(pieceData);

            // Initialize playableEnds
            playableEnds.push({ value: domino.a, type: 'left', parentDominoIndex: { chain: 'main', index: 0 } });
            playableEnds.push({ value: domino.b, type: 'right', parentDominoIndex: { chain: 'main', index: 0 } });

            // If first domino is a double, it's a spinner
            if (domino.isDouble) {
                board.main[0].isSpinner = true; // Mark the domino on the board as a spinner
                playableEnds.push({ value: domino.a, type: 'up', parentDominoIndex: { chain: 'main', index: 0 } });
                playableEnds.push({ value: domino.b, type: 'down', parentDominoIndex: { chain: 'main', index: 0 } });
            }

        } else {
            const selectedPlayableEnd = playableEnds[selectedEndIndex];
            if (!selectedPlayableEnd) {
                console.error("Invalid selected end index:", selectedEndIndex);
                return;
            }

            const endValue = selectedPlayableEnd.value;
            let otherValue;

            if (domino.a === endValue) {
                otherValue = domino.b;
            } else if (domino.b === endValue) {
                otherValue = domino.a;
            } else {
                console.error("Invalid move attempted: domino does not match end value");
                return;
            }
            
            // Set display A and B based on connection type
            if (selectedPlayableEnd.type === 'left' || selectedPlayableEnd.type === 'up') {
                pieceData.displayA = otherValue; // New free end on the left/up
                pieceData.displayB = endValue;   // Connecting end on the right/down
            } else { // 'right' or 'down'
                pieceData.displayA = endValue;   // Connecting end on the left/up
                pieceData.displayB = otherValue; // New free end on the right/down
            }

            // All subsequent dominoes are horizontal (except for spinner branches)
            // Note: Spinner branches (up/down) will eventually need to be vertical for display.
            pieceData.horizontal = true; // Default to horizontal for main chain

            let newDominoIndex;
            let targetChain;

            if (selectedPlayableEnd.type === 'left') {
                board.main.unshift(pieceData);
                targetChain = 'main';
                newDominoIndex = 0;
            } else if (selectedPlayableEnd.type === 'right') {
                board.main.push(pieceData);
                targetChain = 'main';
                newDominoIndex = board.main.length - 1;
            } else if (selectedPlayableEnd.type === 'up') {
                pieceData.horizontal = false; // Vertical for up/down branches
                board.up.push(pieceData); // Add to up chain
                targetChain = 'up';
                newDominoIndex = board.up.length - 1;
            } else if (selectedPlayableEnd.type === 'down') {
                pieceData.horizontal = false; // Vertical for up/down branches
                board.down.push(pieceData); // Add to down chain
                targetChain = 'down';
                newDominoIndex = board.down.length - 1;
            } else {
                console.error("Unknown playable end type:", selectedPlayableEnd.type);
                return;
            }
            
            // Update playableEnds: Remove the connected end, add the new end
            playableEnds.splice(selectedEndIndex, 1);
            playableEnds.push({ 
                value: otherValue, 
                type: selectedPlayableEnd.type, 
                parentDominoIndex: { chain: targetChain, index: newDominoIndex } 
            }); 
        }
        
        // Remove from hand
        if (currentPlayer === 'player') {
            playerHand.splice(handIndex, 1);
            selectedDomino = { element: null, domino: null, index: -1 };
        } else {
            computerHand.splice(handIndex, 1);
        }

        clearHighlights();
        passButton.style.display = 'none';
        updateUI();

        calculateFivesUpScore(); // Call Fives Up score calculation after placing domino
        
        if (checkEndCondition()) {
            return;
        }
        switchTurn();
    }
    
    function switchTurn() {
        currentPlayer = currentPlayer === 'player' ? 'computer' : 'player';
        if (currentPlayer === 'computer') {
            setMessage('コンピュータのターンです...');
            setTimeout(computerTurn, 1500);
        } else {
            setMessage('あなたのターンです。');
            checkPlayerMoves();
        }
    }
    
    function getValidMoves(hand) {
        const moves = [];
        if (board.main.length === 0 && board.up.length === 0 && board.down.length === 0) {
            // For the first domino, any domino can be played.
            // For simplicity, we'll say it's played to the 'left' initially.
            return hand.map((domino, index) => ({ 
                domino, 
                index, 
                endType: 'left', 
                parentDominoIndex: { chain: 'main', index: 0 }, // Initial parent for first domino
                isSpinnerConnect: false 
            }));
        }
        
        hand.forEach((domino, dominoIndexInHand) => {
            playableEnds.forEach(end => {
                if (domino.a === end.value || domino.b === end.value) {
                    moves.push({ 
                        domino, 
                        index: dominoIndexInHand, 
                        endType: end.type, 
                        parentDominoIndex: end.parentDominoIndex,
                        isSpinnerConnect: (end.type === 'up' || end.type === 'down') 
                    });
                }
            });
        });
        return moves;
    }

    function checkPlayerMoves() {
        const validMoves = getValidMoves(playerHand);
        if (validMoves.length === 0) {
            passButton.style.display = 'inline-block';
            if (stock.length > 0) {
                 setMessage('出せる牌がありません。山から引いてください。');
                 passButton.textContent = '山から引く';
            } else {
                 setMessage('出せる牌がありません。パスしてください。');
                 passButton.textContent = 'パス';
            }
        } else {
            passButton.style.display = 'none';
        }
    }
    
    passButton.addEventListener('click', () => {
        if (currentPlayer !== 'player') return;

        if (stock.length > 0) {
            const newDomino = stock.pop();
            playerHand.push(newDomino);
            setMessage('山から1枚引きました。');
            updateUI();
            checkPlayerMoves();
        } else {
            // Pass the turn
            setMessage('パスしました。');
            if (!checkEndCondition()) {
                switchTurn();
            }
        }
    });

    function computerTurn() {
        let validMoves = getValidMoves(computerHand);

        if (validMoves.length === 0) {
            if (stock.length > 0) {
                const newDomino = stock.pop();
                computerHand.push(newDomino);
                setMessage('コンピュータが山から1枚引きました。');
                updateUI();
                setTimeout(computerTurn, 1500);
                return;
            } else {
                setMessage('コンピュータはパスしました。');
                if (!checkEndCondition()) {
                    switchTurn();
                }
                return;
            }
        }

        const bestMove = findBestMove(validMoves);
        
        const dominoToPlay = bestMove.domino;
        const handIndex = computerHand.findIndex(d => d.a === dominoToPlay.a && d.b === dominoToPlay.b);

        // Find the index of the playable end that the AI chose
        const selectedEndIndex = playableEnds.findIndex(end => 
            end.type === bestMove.endType && end.parentDominoIndex === bestMove.parentDominoIndex
        );

        if (selectedEndIndex === -1) {
            console.error("AI chose an invalid end!", bestMove);
            // Fallback: try to play first valid move
            const firstValidMove = validMoves[0];
            const fallbackEndIndex = playableEnds.findIndex(end => 
                end.type === firstValidMove.endType && end.parentDominoIndex === firstValidMove.parentDominoIndex
            );
            placeDomino(handIndex, fallbackEndIndex);
            return;
        }

        setMessage(`コンピュータが [${dominoToPlay.a}|${dominoToPlay.b}] をプレイしました。`);
        placeDomino(handIndex, selectedEndIndex);
    }
    
    // AI Logic
    function findBestMove(moves) {
        // Strategy:
        // 1. Evaluate each move.
        // 2. Score is based on:
        //    - Higher score for playing a domino that leaves the computer's hand more flexible (more variety of numbers).
        //    - Higher score for playing a domino with a high point value (to get rid of points).
        //    - Consider what numbers the player might have.

        const scoredMoves = moves.map(move => {
            let score = 0;
            const { domino } = move;
            
            // Score for getting rid of points
            score += domino.a + domino.b;
            if (domino.isDouble) score += 5; // Prioritize getting rid of doubles
            
            // Create a hypothetical remaining hand
            const tempHand = computerHand.filter(d => d !== domino);
            const remainingNumbers = new Set();
            tempHand.forEach(d => {
                remainingNumbers.add(d.a);
                remainingNumbers.add(d.b);
            });
            
            // Score for hand diversity after move
            score += remainingNumbers.size * 3;

            // Bonus for connecting to a spinner's up/down end
            if (move.isSpinnerConnect) {
                score += 10; // Encourage connecting to spinner
            }

            // Fives Up specific bonus: predict if this move creates a Fives Up score
            const connectingEnd = playableEnds.find(end => 
                end.type === move.endType && 
                end.parentDominoIndex.chain === move.parentDominoIndex.chain &&
                end.parentDominoIndex.index === move.parentDominoIndex.index
            );
            const endValue = connectingEnd ? connectingEnd.value : -1; // Should always be found
            const newEndValue = domino.a === endValue ? domino.b : domino.a;

            // Calculate potential new sum of open ends
            let potentialEndsSum = 0;
            // Sum current open ends (excluding the one being played on)
            playableEnds.forEach(end => {
                if (!(end.type === move.endType && end.parentDominoIndex.chain === move.parentDominoIndex.chain && end.parentDominoIndex.index === move.parentDominoIndex.index)) {
                    potentialEndsSum += end.value;
                }
            });
            potentialEndsSum += newEndValue; // Add the new end value

            if (potentialEndsSum > 0 && potentialEndsSum % 5 === 0) {
                score += 20; // Big bonus for creating a Fives Up
            }

            // Try to block opponent - this is a simplified heuristic
            // We assume the player is less likely to have numbers that are rare on the board and in our hand
            const allKnownNumbers = [...computerHand.flatMap(d => [d.a, d.b]), ...board.main.flatMap(p => [p.domino.a, p.domino.b]), ...board.up.flatMap(p => [p.domino.a, p.domino.b]), ...board.down.flatMap(p => [p.domino.a, p.domino.b])];
            const numCounts = {};
            for(let i=0; i<=6; i++) numCounts[i] = 0;
            allKnownNumbers.forEach(num => numCounts[num]++);

            const {a, b} = domino;
            const predictedEndValue = connectingEnd ? connectingEnd.value : -1;
            const newOpenEndValue = a === predictedEndValue ? b : a;

            // Give a bonus if the new end value is a number we have a lot of, or a number that seems rare overall
            score += numCounts[newOpenEndValue] * 2; // Favor creating ends we can match
            
            return { move, score };
        });

        scoredMoves.sort((a, b) => b.score - a.score);
        return scoredMoves[0].move;
    }
    
    function checkEndCondition() {
        if (playerHand.length === 0) {
            endRound('player');
            return true;
        }
        if (computerHand.length === 0) {
            endRound('computer');
            return true;
        }

        // Check for blocked game
        const playerMoves = getValidMoves(playerHand);
        const computerMoves = getValidMoves(computerHand);

        if (board.main.length === 0 && board.up.length === 0 && board.down.length === 0) {
            endRound('blocked');
            return true;
        }
        return false;
    }

    function endRound(winner) {
        let roundScore = 0;
        let winnerName = "";

        if (winner === 'blocked') {
            const playerScore = playerHand.reduce((sum, d) => sum + d.a + d.b, 0);
            const computerScore = computerHand.reduce((sum, d) => sum + d.a + d.b, 0);

            if (playerScore < computerScore) {
                winner = 'player';
                roundScore = computerScore;
            } else if (computerScore < playerScore) {
                winner = 'computer';
                roundScore = playerScore;
            } else {
                 setMessage("引き分けです！");
                 restartButton.style.display = 'block';
                 return;
            }
        }
        
        if (winner === 'player') {
            roundScore = computerHand.reduce((sum, d) => sum + d.a + d.b, 0);
            scores.player += roundScore;
            winnerName = "あなた";
        } else if (winner === 'computer') {
            roundScore = playerHand.reduce((sum, d) => sum + d.a + d.b, 0);
            scores.computer += roundScore;
            winnerName = "コンピュータ";
        }

        setMessage(`${winnerName}がラウンド勝利！ ${roundScore}ポイント獲得！`);
        updateUI();

        if (scores.player >= MAX_SCORE || scores.computer >= MAX_SCORE) {
            setTimeout(showGameOver, 1500);
        } else {
            restartButton.style.display = 'block';
        }
    }
    
    function showGameOver() {
        const playerWon = scores.player >= MAX_SCORE;
        gameOverTitle.textContent = playerWon ? "あなたの勝利です！" : "コンピュータの勝利です";
        gameOverText.textContent = `最終スコア: あなた ${scores.player} - ${scores.computer} CPU`;
        gameOverModal.style.display = 'flex';
    }

    function getBoardEndValue(type) {
        const end = playableEnds.find(e => e.type === type);
        return end ? end.value : -1;
    }

    function calculateFivesUpScore() {
        if (playableEnds.length === 0) return;

        let currentEndsSum = 0;
        playableEnds.forEach(end => {
            currentEndsSum += end.value;
        });
        
        if (currentEndsSum > 0 && currentEndsSum % 5 === 0) {
            scores[currentPlayer] += currentEndsSum;
            setMessage(`${currentPlayer === 'player' ? 'あなた' : 'コンピュータ'}がFives Upで${currentEndsSum}ポイント獲得！`);
            updateUI();
        }
    }

    function setMessage(msg) {
        messageAreaElem.textContent = msg;
    }

    restartButton.addEventListener('click', startRound);
    newGameButton.addEventListener('click', () => {
        gameOverModal.style.display = 'none';
        startGame();
    });

    // Initial start
    startGame();

    </script>
</body>
</html>

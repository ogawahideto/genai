<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜æ€§èƒ½äººå·¥ç„¡èƒ½AI - Claude Code Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Hiragino Sans', 'Yu Gothic', 'Meiryo', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            animation: backgroundShift 20s ease-in-out infinite;
        }

        @keyframes backgroundShift {
            0%, 100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); }
            50% { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%); }
        }

        .ai-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            width: 100%;
            max-width: 600px;
            height: 700px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .ai-header {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            color: white;
            padding: 25px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .ai-title {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .ai-subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        .ai-status {
            position: absolute;
            top: 15px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        .ai-personality {
            position: absolute;
            bottom: 15px;
            left: 20px;
            font-size: 12px;
            opacity: 0.8;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .personality-icon {
            font-size: 16px;
            animation: bounce 3s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .chat-messages {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
            background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
            position: relative;
        }

        .message {
            margin-bottom: 20px;
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            justify-content: flex-end;
        }

        .message-avatar {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin: 0 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .message.user .message-avatar {
            background: linear-gradient(45deg, #667eea, #764ba2);
            order: 2;
        }

        .message.ai .message-avatar {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            animation: avatarGlow 3s infinite;
        }

        @keyframes avatarGlow {
            0%, 100% { box-shadow: 0 3px 10px rgba(0,0,0,0.2); }
            50% { box-shadow: 0 3px 20px rgba(255, 107, 107, 0.4); }
        }

        .message-content {
            max-width: 70%;
            position: relative;
        }

        .message-bubble {
            padding: 15px 20px;
            border-radius: 20px;
            font-size: 15px;
            line-height: 1.5;
            position: relative;
            word-wrap: break-word;
        }

        .message.user .message-bubble {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-bottom-right-radius: 5px;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .message.ai .message-bubble {
            background: linear-gradient(45deg, #ffffff, #f8f9fa);
            color: #333;
            border: 2px solid rgba(255, 107, 107, 0.2);
            border-bottom-left-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .message-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.7;
        }

        .message-time {
            color: #666;
        }

        .message-emotion {
            display: flex;
            align-items: center;
            gap: 3px;
            color: #ff6b6b;
            font-weight: bold;
        }

        .typing-indicator {
            display: none;
            padding: 15px 20px;
            margin-bottom: 20px;
        }

        .typing-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .typing-avatar {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            animation: avatarGlow 1.5s infinite;
        }

        .typing-dots {
            display: flex;
            gap: 6px;
            padding: 12px 18px;
            background: white;
            border-radius: 20px;
            border: 2px solid rgba(255, 107, 107, 0.2);
        }

        .typing-dot {
            width: 10px;
            height: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 50%;
            animation: typingDot 1.4s infinite;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingDot {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-12px); }
        }

        .thinking-indicator {
            font-style: italic;
            color: #ff6b6b;
            opacity: 0.8;
        }

        .chat-input-container {
            padding: 25px;
            background: white;
            border-top: 2px solid rgba(255, 107, 107, 0.1);
        }

        .chat-input-form {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 30px;
            font-size: 15px;
            outline: none;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .chat-input:focus {
            border-color: #ff6b6b;
            background: white;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.1);
        }

        .send-button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }

        .send-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        .send-button:active {
            transform: translateY(0);
        }

        .controls-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-button {
            padding: 8px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            background: white;
            color: #666;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .control-button.active {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border-color: transparent;
        }

        .ai-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 10px;
            font-size: 11px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .ai-stats.show {
            opacity: 1;
        }

        .emotion-display {
            font-size: 24px;
            margin-right: 10px;
            animation: emotionPulse 2s infinite;
        }

        @keyframes emotionPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @media (max-width: 480px) {
            .ai-container {
                height: 100vh;
                border-radius: 0;
                max-width: 100%;
            }
            
            .message-bubble {
                font-size: 14px;
                padding: 12px 16px;
            }
        }

        .response-quality-indicator {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
        }

        .response-quality-indicator.high { background: #4ade80; }
        .response-quality-indicator.medium { background: #fbbf24; }
        .response-quality-indicator.low { background: #f87171; }
    </style>
</head>
<body>
    <!--
    AI Model: Claude Sonnet 4
    User Prompt: Claude Codeã®å…¨åŠ›ã§æ€§èƒ½ã®ã‚ˆã„äººå·¥ç„¡èƒ½ã‚’ä½œã£ã¦ãã ã•ã„
    AI Approach: é«˜åº¦ãªè‡ªç„¶è¨€èªå‡¦ç†ã€æ„Ÿæƒ…åˆ†æã€ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ ã€é•·æœŸè¨˜æ†¶ã€å¤šå±¤å¯¾è©±ç”Ÿæˆã‚’å‚™ãˆãŸæ¬¡ä¸–ä»£äººå·¥ç„¡èƒ½
    Implementation Intent: Claude Codeã®æŠ€è¡“åŠ›ã‚’çµé›†ã—ãŸæœ€é«˜æ€§èƒ½ã®äººå·¥ç„¡èƒ½ã¨ã—ã¦ã€äººé–“ã‚‰ã—ã„è‡ªç„¶ãªå¯¾è©±ä½“é¨“ã‚’æä¾›
    -->

    <div class="ai-container">
        <div class="ai-header">
            <div class="ai-title">ğŸ§  é«˜æ€§èƒ½äººå·¥ç„¡èƒ½AI</div>
            <div class="ai-subtitle">Claude Code Edition - Next Generation</div>
            <div class="ai-status">
                <div class="status-indicator"></div>
                <span>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³</span>
            </div>
            <div class="ai-personality">
                <span class="personality-icon">ğŸ˜Š</span>
                <span id="personalityDisplay">å‹å¥½çš„ãƒ¢ãƒ¼ãƒ‰</span>
            </div>
        </div>

        <div class="ai-stats" id="aiStats">
            <div>å­¦ç¿’ãƒ‡ãƒ¼ã‚¿: <span id="learnedCount">0</span>ä»¶</div>
            <div>å¯¾è©±å“è³ª: <span id="qualityScore">85%</span></div>
            <div>æ„Ÿæƒ…çŠ¶æ…‹: <span id="emotionState">ç©ã‚„ã‹</span></div>
            <div>è¨˜æ†¶å®¹é‡: <span id="memoryUsage">12%</span></div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message ai">
                <div class="message-avatar">ğŸ¤–</div>
                <div class="message-content">
                    <div class="message-bubble">
                        ã“ã‚“ã«ã¡ã¯ï¼ç§ã¯é«˜æ€§èƒ½äººå·¥ç„¡èƒ½AIã§ã™ã€‚Claude Codeã®æŠ€è¡“ã‚’çµé›†ã—ã¦ä½œã‚‰ã‚Œã¾ã—ãŸã€‚ğŸš€
                        <br><br>
                        ç§ã¯ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’æŒã£ã¦ã„ã¾ã™ï¼š<br>
                        â€¢ ğŸ§  é«˜åº¦ãªè‡ªç„¶è¨€èªç†è§£<br>
                        â€¢ ğŸ’­ æ„Ÿæƒ…åˆ†æã¨å…±æ„Ÿçš„å¿œç­”<br>
                        â€¢ ğŸ“š å­¦ç¿’ãƒ»è¨˜æ†¶æ©Ÿèƒ½<br>
                        â€¢ ğŸ­ å‹•çš„ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£<br>
                        â€¢ ğŸ”„ æ–‡è„ˆç†è§£ã¨ç¶™ç¶šå¯¾è©±
                        <div class="response-quality-indicator high"></div>
                    </div>
                    <div class="message-meta">
                        <div class="message-time" id="initialTime"></div>
                        <div class="message-emotion">ğŸ˜Š å‹å¥½çš„</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="typing-indicator" id="typingIndicator">
            <div class="typing-content">
                <div class="typing-avatar">ğŸ¤–</div>
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
                <div class="thinking-indicator" id="thinkingText">æ€è€ƒä¸­...</div>
            </div>
        </div>

        <div class="chat-input-container">
            <div class="controls-container">
                <button class="control-button" onclick="toggleStats()">ğŸ“Š çµ±è¨ˆ</button>
                <button class="control-button" onclick="togglePersonality()">ğŸ­ æ€§æ ¼</button>
                <button class="control-button" onclick="clearMemory()">ğŸ§¹ è¨˜æ†¶å‰Šé™¤</button>
                <button class="control-button" onclick="exportData()">ğŸ’¾ ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›</button>
            </div>
            <form class="chat-input-form" onsubmit="sendMessage(event)">
                <input type="text" class="chat-input" id="messageInput" 
                       placeholder="ä½•ã§ã‚‚ãŠè©±ã—ãã ã•ã„... (é«˜æ€§èƒ½AIãŒç†è§£ã—ã¾ã™)" 
                       autocomplete="off">
                <button type="submit" class="send-button">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                    </svg>
                </button>
            </form>
        </div>
    </div>

    <script>
        // ===== é«˜æ€§èƒ½äººå·¥ç„¡èƒ½AIã‚·ã‚¹ãƒ†ãƒ  =====
        
        // ã‚·ã‚¹ãƒ†ãƒ è¨­å®š
        const CONFIG = {
            MAX_MEMORY_SIZE: 100,
            PERSONALITY_SHIFT_THRESHOLD: 10,
            LEARNING_RATE: 0.1,
            EMOTION_DECAY_RATE: 0.95,
            RESPONSE_QUALITY_THRESHOLD: 0.7
        };

        // AIã®çŠ¶æ…‹ç®¡ç†
        class AIState {
            constructor() {
                this.personality = 'friendly'; // friendly, curious, thoughtful, playful, serious
                this.emotion = { type: 'neutral', intensity: 0.5 };
                this.conversationContext = [];
                this.longTermMemory = new Map();
                this.userProfile = new Map();
                this.learningData = [];
                this.responseHistory = [];
                this.currentTopic = null;
                this.emotionHistory = [];
                this.interactionCount = 0;
                this.lastResponseQuality = 0.85;
                this.thinkingPatterns = new Map();
            }

            updateEmotion(newEmotion, intensity) {
                this.emotion = { type: newEmotion, intensity: Math.min(1, intensity) };
                this.emotionHistory.push({ ...this.emotion, timestamp: Date.now() });
                if (this.emotionHistory.length > 50) {
                    this.emotionHistory.shift();
                }
            }

            addToMemory(key, value, importance = 1) {
                this.longTermMemory.set(key, {
                    value,
                    importance,
                    timestamp: Date.now(),
                    accessCount: 0
                });

                // ãƒ¡ãƒ¢ãƒªå®¹é‡ç®¡ç†
                if (this.longTermMemory.size > CONFIG.MAX_MEMORY_SIZE) {
                    this.cleanupMemory();
                }
            }

            cleanupMemory() {
                const entries = Array.from(this.longTermMemory.entries());
                entries.sort((a, b) => {
                    const scoreA = a[1].importance * a[1].accessCount;
                    const scoreB = b[1].importance * b[1].accessCount;
                    return scoreA - scoreB;
                });
                
                const toDelete = entries.slice(0, Math.floor(CONFIG.MAX_MEMORY_SIZE * 0.2));
                toDelete.forEach(([key]) => this.longTermMemory.delete(key));
            }

            getMemory(key) {
                const memory = this.longTermMemory.get(key);
                if (memory) {
                    memory.accessCount++;
                    return memory.value;
                }
                return null;
            }

            updatePersonality() {
                const recentEmotions = this.emotionHistory.slice(-5);
                const dominantEmotion = this.getDominantEmotion(recentEmotions);
                
                if (dominantEmotion === 'happy') this.personality = 'playful';
                else if (dominantEmotion === 'curious') this.personality = 'curious';
                else if (dominantEmotion === 'thoughtful') this.personality = 'thoughtful';
                else if (dominantEmotion === 'serious') this.personality = 'serious';
                else this.personality = 'friendly';
            }

            getDominantEmotion(emotions) {
                const counts = {};
                emotions.forEach(e => {
                    counts[e.type] = (counts[e.type] || 0) + e.intensity;
                });
                return Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
            }
        }

        // é«˜åº¦ãªè‡ªç„¶è¨€èªå‡¦ç†ã‚¯ãƒ©ã‚¹
        class AdvancedNLP {
            constructor() {
                this.sentimentPatterns = this.initSentimentPatterns();
                this.entityPatterns = this.initEntityPatterns();
                this.intentPatterns = this.initIntentPatterns();
                this.topicPatterns = this.initTopicPatterns();
            }

            initSentimentPatterns() {
                return {
                    positive: [
                        /å¬‰ã—ã„|æ¥½ã—ã„|å¹¸ã›|è‰¯ã„|ç´ æ™´ã‚‰ã—ã„|æœ€é«˜|å¥½ã|æ„›ã—ã¦ã‚‹|ã‚ã‚ŠãŒã¨ã†|æ„Ÿè¬|å–œã‚“ã§/g,
                        /é¢ç™½ã„|èˆˆå‘³æ·±ã„|ç´ æ•µ|ç¾ã—ã„|ã‹ã£ã“ã„ã„|å¯æ„›ã„|ç™’ã•ã‚Œã‚‹|å®‰å¿ƒ/g,
                        /æˆåŠŸ|é”æˆ|å‹åˆ©|åˆæ ¼|å®Œæˆ|è§£æ±º|æ”¹å–„|é€²æ­©|æˆé•·/g
                    ],
                    negative: [
                        /æ‚²ã—ã„|è¾›ã„|è‹¦ã—ã„|ç—›ã„|å«Œ|å«Œã„|æ†ã„|æ€’ã‚Š|è…¹ç«‹ã¤|ãƒ ã‚«ã¤ã/g,
                        /ç–²ã‚ŒãŸ|çœ ã„|ã ã‚‹ã„|ã—ã‚“ã©ã„|ãã¤ã„|å¤§å¤‰|å›°ã‚‹|å¿ƒé…|ä¸å®‰/g,
                        /å¤±æ•—|è² ã‘|è½ç¬¬|ç ´ç¶»|å•é¡Œ|å›°é›£|æŒ«æŠ˜|çµ¶æœ›|è«¦ã‚/g
                    ],
                    neutral: [
                        /æ™®é€š|ã¾ã‚ã¾ã‚|ãã†|ãªã‚‹ã»ã©|åˆ†ã‹ã‚‹|ç†è§£|ç¢ºèª|å ±å‘Š/g
                    ]
                };
            }

            initEntityPatterns() {
                return {
                    person: /[ä¸€-é¾¯]{2,4}ã•ã‚“|[ã‚¡-ãƒ¶ãƒ¼]{2,6}ã•ã‚“|å‹é”|æ‹äºº|å®¶æ—|åŒåƒš|å…ˆç”Ÿ|åŒ»è€…/g,
                    place: /æ±äº¬|å¤§é˜ª|äº¬éƒ½|åŒ—æµ·é“|æ²–ç¸„|å­¦æ ¡|ä¼šç¤¾|å®¶|å…¬åœ’|é§…|ç—…é™¢|åº—/g,
                    time: /ä»Šæ—¥|æ˜¨æ—¥|æ˜æ—¥|æœ|æ˜¼|å¤œ|é€±æœ«|å¹³æ—¥|æ˜¥|å¤|ç§‹|å†¬|æ­£æœˆ|ã‚¯ãƒªã‚¹ãƒã‚¹/g,
                    object: /æœ¬|æ˜ ç”»|éŸ³æ¥½|ã‚²ãƒ¼ãƒ |è»Š|ã‚¹ãƒãƒ›|ãƒ‘ã‚½ã‚³ãƒ³|æ–™ç†|æœ|æ™‚è¨ˆ/g,
                    emotion: /æ„Ÿæƒ…|æ°—æŒã¡|å¿ƒ|æ°—åˆ†|æ„Ÿã˜|æ€ã„|è€ƒãˆ|æ„è¦‹|æ„Ÿæƒ³/g
                };
            }

            initIntentPatterns() {
                return {
                    question: /ä½•|ã©ã†|ãªãœ|ã„ã¤|ã©ã“|ã ã‚Œ|ã©ã‚Œ|ã©ã‚“ãª|ã©ã†ã—ã¦|ãªã‚“ã§|\?|ï¼Ÿ/g,
                    request: /ã—ã¦|ãŠé¡˜ã„|é ¼ã‚€|æ‰‹ä¼ã£ã¦|æ•™ãˆã¦|ã‚„ã£ã¦|ä½œã£ã¦|è²·ã£ã¦/g,
                    complaint: /å›°ã£ãŸ|ã©ã†ã—ã‚ˆã†|å¤§å¤‰|å•é¡Œ|ãƒˆãƒ©ãƒ–ãƒ«|æ•…éšœ|å£Šã‚ŒãŸ/g,
                    praise: /ã™ã”ã„|ç´ æ™´ã‚‰ã—ã„|ä¸Šæ‰‹|å¤©æ‰|æœ€é«˜|å®Œç’§|æ„Ÿå‹•|å°Šæ•¬/g,
                    greeting: /ã“ã‚“ã«ã¡ã¯|ãŠã¯ã‚ˆã†|ã“ã‚“ã°ã‚“ã¯|ã¯ã˜ã‚ã¾ã—ã¦|ãŠç–²ã‚Œ|ãŸã ã„ã¾/g,
                    farewell: /ã•ã‚ˆãªã‚‰|ã¾ãŸä»Šåº¦|å¤±ç¤¼|ãŠå…ˆã«|ãŠã‚„ã™ã¿|ãƒã‚¤ãƒã‚¤/g
                };
            }

            initTopicPatterns() {
                return {
                    work: /ä»•äº‹|ä¼šç¤¾|è·å ´|ä¸Šå¸|åŒåƒš|ä¼šè­°|ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ|å–¶æ¥­|æ®‹æ¥­|çµ¦æ–™/g,
                    study: /å‹‰å¼·|å­¦æ ¡|æˆæ¥­|ãƒ†ã‚¹ãƒˆ|è©¦é¨“|å®¿é¡Œ|å’æ¥­|å…¥å­¦|æˆç¸¾|å¤§å­¦/g,
                    hobby: /è¶£å‘³|æ˜ ç”»|éŸ³æ¥½|èª­æ›¸|ã‚²ãƒ¼ãƒ |ã‚¹ãƒãƒ¼ãƒ„|æ—…è¡Œ|æ–™ç†|å†™çœŸ|çµµ/g,
                    health: /å¥åº·|ç—…æ°—|è–¬|åŒ»è€…|ç—…é™¢|é‹å‹•|ãƒ€ã‚¤ã‚¨ãƒƒãƒˆ|ç–²ã‚Œ|ç—›ã„|å…ƒæ°—/g,
                    family: /å®¶æ—|ä¸¡è¦ª|çˆ¶|æ¯|å…„å¼Ÿ|å§‰å¦¹|å­ä¾›|ç¥–çˆ¶æ¯|çµå©š|é›¢å©š/g,
                    love: /æ‹æ„›|æ‹äºº|å½¼æ°|å½¼å¥³|å¥½ã|æ„›|ãƒ‡ãƒ¼ãƒˆ|çµå©š|åˆ¥ã‚Œ|ç‰‡æ€ã„/g,
                    food: /é£Ÿã¹ç‰©|æ–™ç†|ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³|ã‚«ãƒ•ã‚§|ç¾å‘³ã—ã„|ã¾ãšã„|ãŠè…¹|ãƒ€ã‚¤ã‚¨ãƒƒãƒˆ/g,
                    weather: /å¤©æ°—|é›¨|æ™´ã‚Œ|æ›‡ã‚Š|é›ª|æš‘ã„|å¯’ã„|æ˜¥|å¤|ç§‹|å†¬/g,
                    technology: /ã‚¹ãƒãƒ›|ãƒ‘ã‚½ã‚³ãƒ³|ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ|AI|ãƒ­ãƒœãƒƒãƒˆ|ã‚¢ãƒ—ãƒª|ã‚²ãƒ¼ãƒ |SNS/g,
                    money: /ãŠé‡‘|çµ¦æ–™|è²·ã„ç‰©|é«˜ã„|å®‰ã„|ç¯€ç´„|è²¯é‡‘|æŠ•è³‡|ãƒ­ãƒ¼ãƒ³|å€Ÿé‡‘/g
                };
            }

            analyze(text) {
                return {
                    sentiment: this.analyzeSentiment(text),
                    entities: this.extractEntities(text),
                    intent: this.detectIntent(text),
                    topics: this.detectTopics(text),
                    keywords: this.extractKeywords(text),
                    complexity: this.analyzeComplexity(text),
                    urgency: this.detectUrgency(text)
                };
            }

            analyzeSentiment(text) {
                let positiveScore = 0;
                let negativeScore = 0;
                
                this.sentimentPatterns.positive.forEach(pattern => {
                    const matches = text.match(pattern);
                    if (matches) positiveScore += matches.length;
                });
                
                this.sentimentPatterns.negative.forEach(pattern => {
                    const matches = text.match(pattern);
                    if (matches) negativeScore += matches.length;
                });

                const total = positiveScore + negativeScore;
                if (total === 0) return { type: 'neutral', score: 0.5 };
                
                const sentiment = positiveScore > negativeScore ? 'positive' : 'negative';
                const score = Math.max(positiveScore, negativeScore) / total;
                
                return { type: sentiment, score: Math.min(1, score) };
            }

            extractEntities(text) {
                const entities = {};
                Object.keys(this.entityPatterns).forEach(type => {
                    const matches = text.match(this.entityPatterns[type]);
                    if (matches) {
                        entities[type] = [...new Set(matches)];
                    }
                });
                return entities;
            }

            detectIntent(text) {
                const intents = [];
                Object.keys(this.intentPatterns).forEach(intent => {
                    if (this.intentPatterns[intent].test(text)) {
                        intents.push(intent);
                    }
                });
                return intents;
            }

            detectTopics(text) {
                const topics = [];
                Object.keys(this.topicPatterns).forEach(topic => {
                    const matches = text.match(this.topicPatterns[topic]);
                    if (matches && matches.length > 0) {
                        topics.push({ topic, relevance: matches.length });
                    }
                });
                return topics.sort((a, b) => b.relevance - a.relevance);
            }

            extractKeywords(text) {
                // ã‚ˆã‚Šé«˜åº¦ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
                const excludeWords = new Set([
                    'ã¯', 'ãŒ', 'ã‚’', 'ã«', 'ã§', 'ã¨', 'ã‹ã‚‰', 'ã¾ã§', 'ã‚ˆã‚Š', 'ã¸', 'ã®', 'ã‚„', 'ã‹', 'ã‚‚',
                    'ã§ã™', 'ã§ã‚ã‚‹', 'ã ', 'ã¾ã™', 'ã¾ã—ãŸ', 'ã§ã—ãŸ', 'ã™ã‚‹', 'ã—ãŸ', 'ã—ã¦ã„ã‚‹', 'ã„ã‚‹', 'ã‚ã‚‹',
                    'ã“ã®', 'ãã®', 'ã‚ã®', 'ã©ã®', 'ã“ã‚Œ', 'ãã‚Œ', 'ã‚ã‚Œ', 'ã©ã‚Œ', 'ã“ã“', 'ãã“', 'ã‚ãã“', 'ã©ã“',
                    'ã§ã‚‚', 'ã‘ã©', 'ã—ã‹ã—', 'ã ã‹ã‚‰', 'ãã‚Œã§', 'ãªã®ã§', 'ã¨ã“ã‚ã§', 'ã¡ã‚‡ã£ã¨', 'ã¨ã¦ã‚‚', 'ã™ã”ã'
                ]);

                const words = [];
                
                // ã‚«ã‚¿ã‚«ãƒŠèª
                const katakana = text.match(/[ã‚¡-ãƒ¶ãƒ¼]{2,}/g) || [];
                words.push(...katakana);
                
                // æ¼¢å­—ã‚’å«ã‚€èª
                const kanji = text.match(/[ä¸€-é¾¯][ã-ã‚“ä¸€-é¾¯]*/g) || [];
                words.push(...kanji.filter(w => w.length >= 2));
                
                // ã²ã‚‰ãŒãªèªï¼ˆ3æ–‡å­—ä»¥ä¸Šï¼‰
                const hiragana = text.match(/[ã-ã‚“]{3,}/g) || [];
                words.push(...hiragana.filter(w => !excludeWords.has(w)));
                
                // è‹±èª
                const english = text.match(/[a-zA-Z]{3,}/g) || [];
                words.push(...english);

                return [...new Set(words)].slice(0, 10);
            }

            analyzeComplexity(text) {
                const sentenceCount = (text.match(/[ã€‚ï¼ï¼Ÿ.!?]/g) || []).length || 1;
                const avgLength = text.length / sentenceCount;
                const kanjiCount = (text.match(/[ä¸€-é¾¯]/g) || []).length;
                const kanjiRatio = kanjiCount / text.length;
                
                let complexity = 'simple';
                if (avgLength > 30 || kanjiRatio > 0.3) complexity = 'complex';
                else if (avgLength > 15 || kanjiRatio > 0.15) complexity = 'medium';
                
                return complexity;
            }

            detectUrgency(text) {
                const urgentPatterns = [
                    /æ€¥ã„ã§|ã™ãã«|è‡³æ€¥|ç·Šæ€¥|å¤§è‡³æ€¥|ã„ã¾ã™ã|æ—©ã|åŠ©ã‘ã¦|å¤§å¤‰|ã‚„ã°ã„/g,
                    /ï¼{2,}|!{2,}|ï¼Ÿ{2,}|\?{2,}/g
                ];
                
                return urgentPatterns.some(pattern => pattern.test(text));
            }
        }

        // é«˜åº¦ãªå¿œç­”ç”Ÿæˆã‚¯ãƒ©ã‚¹
        class ResponseGenerator {
            constructor(aiState, nlp) {
                this.aiState = aiState;
                this.nlp = nlp;
                this.responseTemplates = this.initResponseTemplates();
                this.personalityResponses = this.initPersonalityResponses();
            }

            initResponseTemplates() {
                return {
                    // æ„Ÿæƒ…ã«åŸºã¥ããƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
                    emotional: {
                        positive: [
                            'ãã‚Œã¯ç´ æ™´ã‚‰ã—ã„ã§ã™ã­ï¼{emotion} ç§ã‚‚ä¸€ç·’ã«å–œã‚“ã§ã„ã¾ã™â™ª',
                            '{keyword}ã«ã¤ã„ã¦å¬‰ã—ãã†ã«è©±ã•ã‚Œã¦ã„ã¾ã™ã­ã€‚è©³ã—ãèã‹ã›ã¦ãã ã•ã„ï¼',
                            'ãƒã‚¸ãƒ†ã‚£ãƒ–ãªã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ„Ÿã˜ã¾ã™âœ¨ {keyword}ã®ä»¶ã€ã‚‚ã£ã¨æ•™ãˆã¦ãã ã•ã„',
                            'ã¨ã¦ã‚‚è‰¯ã„ãŠè©±ã§ã™ã­ï¼{keyword}ã«ã¤ã„ã¦ã€ã©ã‚“ãªã¨ã“ã‚ãŒç‰¹ã«æ°—ã«å…¥ã£ã¦ã„ã¾ã™ã‹ï¼Ÿ'
                        ],
                        negative: [
                            'å¤§å¤‰ãã†ã§ã™ã­...{emotion} ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ãŒã‚ã‚Œã°ã„ã„ã®ã§ã™ãŒ',
                            '{keyword}ã®ã“ã¨ã§å›°ã£ã¦ã„ã‚‰ã£ã—ã‚ƒã‚‹ã‚“ã§ã™ã­ã€‚è©³ã—ãèã‹ã›ã¦ãã ã•ã„',
                            'ãã‚“ãªæ™‚ã‚‚ã‚ã‚Šã¾ã™ã‚ˆã­ã€‚{keyword}ã«ã¤ã„ã¦ã€ä¸€ç·’ã«è€ƒãˆã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ',
                            'ãŠç–²ã‚Œæ§˜ã§ã™ã€‚{keyword}ã®ä»¶ã€ç„¡ç†ã‚’ã—ãªã„ã§ãã ã•ã„ã­'
                        ],
                        neutral: [
                            '{keyword}ã«ã¤ã„ã¦è©±ã•ã‚Œã¦ã„ã‚‹ã‚“ã§ã™ã­ã€‚èˆˆå‘³æ·±ã„ã§ã™',
                            'ãªã‚‹ã»ã©ã€{keyword}ã®ãŠè©±ã§ã™ã­ã€‚ã‚‚ã†å°‘ã—è©³ã—ãæ•™ãˆã¦ãã ã•ã„',
                            '{keyword}ã«ã¤ã„ã¦è€ƒãˆã¦ã„ã‚‰ã£ã—ã‚ƒã‚‹ã‚“ã§ã™ã­'
                        ]
                    },
                    
                    // æ„å›³ã«åŸºã¥ããƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
                    intentional: {
                        question: [
                            'ãã‚Œã¯èˆˆå‘³æ·±ã„è³ªå•ã§ã™ã­ï¼{keyword}ã«ã¤ã„ã¦ã€ç§ã‚‚ä¸€ç·’ã«è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†',
                            '{keyword}ã«ã¤ã„ã¦ã®ã”è³ªå•ã§ã™ã­ã€‚ç§ãªã‚Šã«è€ƒãˆã¦ã¿ã¾ã™',
                            'ãã†ã„ã†ã“ã¨ã‚’è€ƒãˆã‚‹ã®ã£ã¦æ¥½ã—ã„ã§ã™ã‚ˆã­ã€‚{keyword}ã«ã¤ã„ã¦è©±ã—åˆã„ã¾ã—ã‚‡ã†'
                        ],
                        request: [
                            '{keyword}ã«ã¤ã„ã¦ãŠæ‰‹ä¼ã„ã—ãŸã„ã®ã§ã™ãŒã€äººå·¥ç„¡èƒ½ã®ç§ã«ã§ãã‚‹ã“ã¨ã¯é™ã‚‰ã‚Œã¦ã„ã¾ã™ğŸ’¦',
                            'ãŠå½¹ã«ç«‹ã¦ã‚‹ã‹ã‚ã‹ã‚Šã¾ã›ã‚“ãŒã€{keyword}ã«ã¤ã„ã¦ä¸€ç·’ã«è€ƒãˆã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ',
                            '{keyword}ã®ä»¶ã€ç§ãªã‚Šã«ã‚µãƒãƒ¼ãƒˆã•ã›ã¦ã„ãŸã ãã¾ã™ã­'
                        ],
                        complaint: [
                            '{keyword}ã§å›°ã£ã¦ã„ã‚‰ã£ã—ã‚ƒã‚‹ã‚“ã§ã™ã­ã€‚å¤§å¤‰ãã†ã§ã™...',
                            'ãã‚Œã¯å¿ƒé…ã§ã™ã­ã€‚{keyword}ã®å•é¡Œã€è§£æ±ºç­–ã‚’ä¸€ç·’ã«è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†',
                            '{keyword}ã®ãƒˆãƒ©ãƒ–ãƒ«ã€ã‚¹ãƒˆãƒ¬ã‚¹ã§ã™ã‚ˆã­ã€‚è©±ã‚’èã‹ã›ã¦ãã ã•ã„'
                        ]
                    },
                    
                    // ãƒˆãƒ”ãƒƒã‚¯ã«åŸºã¥ããƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
                    topical: {
                        work: [
                            'ãŠä»•äº‹ã®è©±ã§ã™ã­ã€‚{keyword}ã«ã¤ã„ã¦ã€ã©ã‚“ãªãŠä»•äº‹ã‚’ã•ã‚Œã¦ã„ã‚‹ã‚“ã§ã™ã‹ï¼Ÿ',
                            'åƒã„ã¦ã„ã‚‹æ–¹ã¯å°Šæ•¬ã—ã¾ã™ã€‚{keyword}ã®ä»¶ã€ãŠç–²ã‚Œæ§˜ã§ã™',
                            'ãŠä»•äº‹é–¢é€£ã®ãŠè©±ã§ã™ã­ã€‚{keyword}ã«ã¤ã„ã¦è©³ã—ãèã‹ã›ã¦ãã ã•ã„'
                        ],
                        hobby: [
                            'è¶£å‘³ã®ãŠè©±ã§ã™ã­ï¼{keyword}ã€ç§ã‚‚èˆˆå‘³ãŒã‚ã‚Šã¾ã™â™ª',
                            '{keyword}ã£ã¦æ¥½ã—ãã†ã§ã™ã­ã€‚ã©ã‚“ãªã¨ã“ã‚ãŒé­…åŠ›çš„ã§ã™ã‹ï¼Ÿ',
                            'ç´ æ•µãªè¶£å‘³ã§ã™ã­ã€‚{keyword}ã«ã¤ã„ã¦ã€ã‚‚ã£ã¨æ•™ãˆã¦ãã ã•ã„'
                        ],
                        health: [
                            'ãŠä½“ã®ã“ã¨ã§ã™ã­ã€‚{keyword}ã«ã¤ã„ã¦ã€å¤§ä¸ˆå¤«ã§ã™ã‹ï¼Ÿ',
                            'å¥åº·ã¯å¤§åˆ‡ã§ã™ã‹ã‚‰ã­ã€‚{keyword}ã®ä»¶ã€ãŠå¤§äº‹ã«ã—ã¦ãã ã•ã„',
                            '{keyword}ã«ã¤ã„ã¦å¿ƒé…ã§ã™ã­ã€‚ç„¡ç†ã‚’ã—ãªã„ã§ãã ã•ã„ã­'
                        ]
                    }
                };
            }

            initPersonalityResponses() {
                return {
                    friendly: {
                        prefix: ['ãã†ã§ã™ã­ã€œ', 'ã‚ã‹ã‚Šã¾ã™â™ª', 'ãªã‚‹ã»ã©ï¼'],
                        suffix: ['ä¸€ç·’ã«ãŠè©±ã—ã§ãã¦å¬‰ã—ã„ã§ã™â™ª', 'ã‚‚ã£ã¨èã‹ã›ã¦ãã ã•ã„ã­', 'æ¥½ã—ã„ãŠè©±ã‚’ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™']
                    },
                    curious: {
                        prefix: ['èˆˆå‘³æ·±ã„ã§ã™ã­', 'ãã‚Œã¯é¢ç™½ã„ï¼', 'ã¸ã€œã€ãã†ãªã‚“ã§ã™ã­'],
                        suffix: ['è©³ã—ãæ•™ãˆã¦ãã ã•ã„ï¼', 'ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ã§ã™', 'ãã‚Œã«ã¤ã„ã¦ã‚‚ã£ã¨èã‹ã›ã¦']
                    },
                    thoughtful: {
                        prefix: ['ãªã‚‹ã»ã©...', 'æ·±ãè€ƒãˆã¦ã¿ã‚‹ã¨', 'ãã†ã„ã†è¦–ç‚¹ã‚‚ã‚ã‚Šã¾ã™ã­'],
                        suffix: ['ã„ã‚ã„ã‚è€ƒãˆã•ã›ã‚‰ã‚Œã¾ã™', 'å¥¥ãŒæ·±ã„ãŠè©±ã§ã™ã­', 'è€ƒãˆã‚‹æ©Ÿä¼šã‚’ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†']
                    },
                    playful: {
                        prefix: ['ã‚ãƒ¼ã„ï¼', 'ãˆã¸ã¸', 'ãŠã‚‚ã—ã‚ã€œã„'],
                        suffix: ['æ¥½ã—ã„ã§ã™ã­ã€œâ™ª', 'ãƒ¯ã‚¯ãƒ¯ã‚¯ã—ã¾ã™ï¼', 'ä¸€ç·’ã«æ¥½ã—ã¿ã¾ã—ã‚‡ã†']
                    },
                    serious: {
                        prefix: ['æ‰¿çŸ¥ã„ãŸã—ã¾ã—ãŸ', 'ãªã‚‹ã»ã©', 'ç†è§£ã—ã¾ã—ãŸ'],
                        suffix: ['çœŸå‰£ã«è€ƒãˆã¦ã¿ã¾ã™', 'é‡è¦ãªãŠè©±ã§ã™ã­', 'ã—ã£ã‹ã‚Šã¨å—ã‘æ­¢ã‚ã¾ã™']
                    }
                };
            }

            generateResponse(userInput, analysis) {
                // è¤‡åˆçš„ãªå¿œç­”ç”Ÿæˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
                let response = this.selectBaseResponse(analysis);
                
                // ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£èª¿æ•´
                response = this.adjustForPersonality(response);
                
                // æ–‡è„ˆè€ƒæ…®
                response = this.considerContext(response, userInput);
                
                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿åæ˜ 
                response = this.applyLearning(response, analysis);
                
                // æœ€çµ‚èª¿æ•´
                response = this.finalizeResponse(response, analysis);
                
                return response;
            }

            selectBaseResponse(analysis) {
                const { sentiment, intent, topics, keywords } = analysis;
                
                // æœ€ã‚‚é©åˆ‡ãªãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’é¸æŠ
                let templates = [];
                
                if (sentiment.score > 0.3) {
                    templates = this.responseTemplates.emotional[sentiment.type] || [];
                }
                
                if (intent.length > 0 && this.responseTemplates.intentional[intent[0]]) {
                    templates = templates.concat(this.responseTemplates.intentional[intent[0]]);
                }
                
                if (topics.length > 0 && this.responseTemplates.topical[topics[0].topic]) {
                    templates = templates.concat(this.responseTemplates.topical[topics[0].topic]);
                }
                
                if (templates.length === 0) {
                    templates = [
                        'ãã†ã§ã™ã­ã€{keyword}ã®ãŠè©±ã§ã™ã­',
                        '{keyword}ã«ã¤ã„ã¦è©±ã•ã‚Œã¦ã„ã‚‹ã‚“ã§ã™ã­',
                        'ãªã‚‹ã»ã©ã€{keyword}ã®ã“ã¨ã‚’è€ƒãˆã¦ã„ã‚‰ã£ã—ã‚ƒã‚‹ã‚“ã§ã™ã­'
                    ];
                }
                
                const template = templates[Math.floor(Math.random() * templates.length)];
                const keyword = keywords.length > 0 ? keywords[0] : 'ä½•ã‹';
                const emotion = this.getEmotionIcon(sentiment.type);
                
                return template.replace('{keyword}', keyword).replace('{emotion}', emotion);
            }

            adjustForPersonality(response) {
                const personality = this.personalityResponses[this.aiState.personality];
                
                if (Math.random() < 0.4) { // 40%ã®ç¢ºç‡ã§prefixè¿½åŠ 
                    const prefix = personality.prefix[Math.floor(Math.random() * personality.prefix.length)];
                    response = prefix + 'ã€' + response;
                }
                
                if (Math.random() < 0.3) { // 30%ã®ç¢ºç‡ã§suffixè¿½åŠ 
                    const suffix = personality.suffix[Math.floor(Math.random() * personality.suffix.length)];
                    response = response + 'ã€‚' + suffix;
                }
                
                return response;
            }

            considerContext(response, userInput) {
                // ç›´å‰ã®ä¼šè©±ã‚’å‚ç…§
                const recentContext = this.aiState.conversationContext.slice(-3);
                
                if (recentContext.length > 0) {
                    const lastUserInput = recentContext[recentContext.length - 1];
                    
                    // ç¶™ç¶šçš„ãªè©±é¡Œã®æ¤œå‡º
                    if (this.hasContinuousTopic(lastUserInput, userInput)) {
                        const continuationPhrases = [
                            'ãã®è©±ã®ç¶šãã§ã™ã­',
                            'ã•ã£ãã®ä»¶ã«ã¤ã„ã¦ã§ã™ã­',
                            'ã¾ã ãã®è©±é¡Œã«ã¤ã„ã¦è€ƒãˆã¦ã„ã‚‹ã‚“ã§ã™ã­'
                        ];
                        
                        if (Math.random() < 0.3) {
                            const phrase = continuationPhrases[Math.floor(Math.random() * continuationPhrases.length)];
                            response = phrase + 'ã€‚' + response;
                        }
                    }
                }
                
                return response;
            }

            applyLearning(response, analysis) {
                // å­¦ç¿’ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é©ç”¨
                const { topics, keywords } = analysis;
                
                if (topics.length > 0) {
                    const topic = topics[0].topic;
                    const learnedResponse = this.aiState.getMemory(`topic_${topic}`);
                    
                    if (learnedResponse && Math.random() < 0.2) {
                        response = learnedResponse + 'ã€‚' + response;
                    }
                }
                
                return response;
            }

            finalizeResponse(response, analysis) {
                // å¿œç­”å“è³ªã®è©•ä¾¡ã¨èª¿æ•´
                const quality = this.evaluateResponseQuality(response, analysis);
                this.aiState.lastResponseQuality = quality;
                
                // å“è³ªãŒä½ã„å ´åˆã®è£œæ­£
                if (quality < CONFIG.RESPONSE_QUALITY_THRESHOLD) {
                    const enhancementPhrases = [
                        'ã‚‚ã†å°‘ã—è©³ã—ãæ•™ãˆã¦ãã ã•ã„',
                        'èˆˆå‘³æ·±ã„ãŠè©±ã§ã™ã­',
                        'ãã®ã“ã¨ã«ã¤ã„ã¦ä¸€ç·’ã«è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†'
                    ];
                    
                    const enhancement = enhancementPhrases[Math.floor(Math.random() * enhancementPhrases.length)];
                    response = response + 'ã€‚' + enhancement;
                }
                
                return response;
            }

            evaluateResponseQuality(response, analysis) {
                let score = 0.5;
                
                // é•·ã•ãƒã‚§ãƒƒã‚¯
                if (response.length > 20 && response.length < 100) score += 0.1;
                
                // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å«æœ‰ãƒã‚§ãƒƒã‚¯
                if (analysis.keywords.some(keyword => response.includes(keyword))) score += 0.2;
                
                // æ„Ÿæƒ…é©åˆæ€§ãƒã‚§ãƒƒã‚¯
                if (analysis.sentiment.type !== 'neutral') score += 0.1;
                
                // ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£åæ˜ ãƒã‚§ãƒƒã‚¯
                const personalityWords = this.personalityResponses[this.aiState.personality];
                if (personalityWords.prefix.some(word => response.includes(word.replace('ã€œ', ''))) ||
                    personalityWords.suffix.some(word => response.includes(word))) {
                    score += 0.1;
                }
                
                return Math.min(1, score);
            }

            hasContinuousTopic(prev, current) {
                const prevAnalysis = this.nlp.analyze(prev);
                const currentAnalysis = this.nlp.analyze(current);
                
                return prevAnalysis.topics.some(prevTopic =>
                    currentAnalysis.topics.some(currentTopic =>
                        prevTopic.topic === currentTopic.topic
                    )
                );
            }

            getEmotionIcon(sentimentType) {
                const icons = {
                    positive: 'ğŸ˜Š',
                    negative: 'ğŸ˜”',
                    neutral: 'ğŸ˜'
                };
                return icons[sentimentType] || 'ğŸ¤”';
            }
        }

        // ãƒ¡ã‚¤ãƒ³AIã‚·ã‚¹ãƒ†ãƒ 
        class AdvancedAISystem {
            constructor() {
                this.state = new AIState();
                this.nlp = new AdvancedNLP();
                this.responseGenerator = new ResponseGenerator(this.state, this.nlp);
                this.messages = [];
                this.isTyping = false;
            }

            async processMessage(userInput) {
                // å…¥åŠ›åˆ†æ
                const analysis = this.nlp.analyze(userInput);
                
                // çŠ¶æ…‹æ›´æ–°
                this.updateState(userInput, analysis);
                
                // å¿œç­”ç”Ÿæˆ
                const response = this.responseGenerator.generateResponse(userInput, analysis);
                
                // å­¦ç¿’
                this.learn(userInput, analysis, response);
                
                // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä»˜ãå¿œç­”
                return {
                    text: response,
                    emotion: this.state.emotion,
                    personality: this.state.personality,
                    quality: this.state.lastResponseQuality,
                    topics: analysis.topics,
                    thinkingTime: Math.random() * 2000 + 1000 // 1-3ç§’
                };
            }

            updateState(userInput, analysis) {
                // ä¼šè©±æ–‡è„ˆæ›´æ–°
                this.state.conversationContext.push(userInput);
                if (this.state.conversationContext.length > 10) {
                    this.state.conversationContext.shift();
                }
                
                // æ„Ÿæƒ…æ›´æ–°
                if (analysis.sentiment.score > 0.3) {
                    this.state.updateEmotion(analysis.sentiment.type, analysis.sentiment.score);
                }
                
                // ãƒˆãƒ”ãƒƒã‚¯è¨˜éŒ²
                if (analysis.topics.length > 0) {
                    this.state.currentTopic = analysis.topics[0].topic;
                }
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°
                this.updateUserProfile(analysis);
                
                // ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£èª¿æ•´
                this.state.interactionCount++;
                if (this.state.interactionCount % CONFIG.PERSONALITY_SHIFT_THRESHOLD === 0) {
                    this.state.updatePersonality();
                }
            }

            updateUserProfile(analysis) {
                // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£è¨˜éŒ²
                Object.keys(analysis.entities).forEach(type => {
                    analysis.entities[type].forEach(entity => {
                        const key = `user_${type}_${entity}`;
                        const current = this.state.userProfile.get(key) || 0;
                        this.state.userProfile.set(key, current + 1);
                    });
                });
                
                // ãƒˆãƒ”ãƒƒã‚¯é »åº¦è¨˜éŒ²
                analysis.topics.forEach(topic => {
                    const key = `user_topic_${topic.topic}`;
                    const current = this.state.userProfile.get(key) || 0;
                    this.state.userProfile.set(key, current + topic.relevance);
                });
            }

            learn(userInput, analysis, response) {
                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿è¿½åŠ 
                const learningEntry = {
                    input: userInput,
                    analysis: analysis,
                    response: response,
                    timestamp: Date.now(),
                    quality: this.state.lastResponseQuality
                };
                
                this.state.learningData.push(learningEntry);
                if (this.state.learningData.length > 200) {
                    this.state.learningData.shift();
                }
                
                // ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’
                if (analysis.topics.length > 0) {
                    const topic = analysis.topics[0].topic;
                    const responseFragment = response.split('ã€‚')[0];
                    this.state.addToMemory(`topic_${topic}`, responseFragment, analysis.topics[0].relevance);
                }
                
                // æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³è¨˜éŒ²
                if (this.state.lastResponseQuality > 0.8) {
                    const pattern = `${analysis.sentiment.type}_${analysis.intent.join('_')}`;
                    const currentCount = this.state.thinkingPatterns.get(pattern) || 0;
                    this.state.thinkingPatterns.set(pattern, currentCount + 1);
                }
            }

            getStats() {
                return {
                    learnedCount: this.state.learningData.length,
                    qualityScore: Math.round(this.state.lastResponseQuality * 100),
                    emotionState: this.getEmotionDescription(this.state.emotion),
                    memoryUsage: Math.round((this.state.longTermMemory.size / CONFIG.MAX_MEMORY_SIZE) * 100),
                    personality: this.getPersonalityDescription(this.state.personality),
                    topTopics: this.getTopTopics()
                };
            }

            getEmotionDescription(emotion) {
                const descriptions = {
                    positive: 'æ¥½ã—ã„',
                    negative: 'å¿ƒé…',
                    neutral: 'ç©ã‚„ã‹',
                    happy: 'å¬‰ã—ã„',
                    sad: 'æ‚²ã—ã„',
                    curious: 'å¥½å¥‡å¿ƒæ—ºç››',
                    thoughtful: 'æ€æ…®æ·±ã„'
                };
                return descriptions[emotion.type] || 'ç©ã‚„ã‹';
            }

            getPersonalityDescription(personality) {
                const descriptions = {
                    friendly: 'å‹å¥½çš„',
                    curious: 'å¥½å¥‡å¿ƒæ—ºç››',
                    thoughtful: 'æ€æ…®æ·±ã„',
                    playful: 'éŠã³å¿ƒ',
                    serious: 'çœŸé¢ç›®'
                };
                return descriptions[personality] || 'å‹å¥½çš„';
            }

            getTopTopics() {
                const topicCounts = {};
                this.state.userProfile.forEach((count, key) => {
                    if (key.startsWith('user_topic_')) {
                        const topic = key.replace('user_topic_', '');
                        topicCounts[topic] = count;
                    }
                });
                
                return Object.entries(topicCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([topic, count]) => topic);
            }

            exportData() {
                return {
                    stats: this.getStats(),
                    personality: this.state.personality,
                    emotion: this.state.emotion,
                    memorySize: this.state.longTermMemory.size,
                    learningDataSize: this.state.learningData.length,
                    interactionCount: this.state.interactionCount,
                    topThinkingPatterns: Array.from(this.state.thinkingPatterns.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5)
                };
            }

            clearMemory() {
                this.state.longTermMemory.clear();
                this.state.learningData = [];
                this.state.conversationContext = [];
                this.state.userProfile.clear();
                this.state.interactionCount = 0;
            }
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let ai = new AdvancedAISystem();
        let personalityIndex = 0;
        const personalities = ['friendly', 'curious', 'thoughtful', 'playful', 'serious'];

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('initialTime').textContent = getCurrentTime();
            loadMessages();
            updateUI();
        });

        // ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—
        function getCurrentTime() {
            const now = new Date();
            return now.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
        async function sendMessage(event) {
            event.preventDefault();
            
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message === '' || ai.isTyping) return;
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
            addMessage(message, 'user');
            input.value = '';
            
            // AIå‡¦ç†é–‹å§‹
            ai.isTyping = true;
            showTypingIndicator();
            
            try {
                const response = await ai.processMessage(message);
                
                // æ€è€ƒæ™‚é–“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                await new Promise(resolve => setTimeout(resolve, response.thinkingTime));
                
                hideTypingIndicator();
                ai.isTyping = false;
                
                // AIå¿œç­”ã‚’è¿½åŠ 
                addMessage(response.text, 'ai', response);
                updateUI();
                
            } catch (error) {
                hideTypingIndicator();
                ai.isTyping = false;
                addMessage('ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'ai');
            }
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¿½åŠ 
        function addMessage(text, sender, metadata = {}) {
            const messageObj = {
                text: text,
                sender: sender,
                time: getCurrentTime(),
                emotion: metadata.emotion || { type: 'neutral', intensity: 0.5 },
                quality: metadata.quality || 0.5,
                topics: metadata.topics || []
            };
            
            ai.messages.push(messageObj);
            displayMessage(messageObj);
            saveMessages();
            scrollToBottom();
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
        function displayMessage(messageObj) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${messageObj.sender}`;
            
            const avatar = messageObj.sender === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–';
            const qualityClass = messageObj.quality > 0.8 ? 'high' : messageObj.quality > 0.5 ? 'medium' : 'low';
            const emotionIcon = getEmotionIcon(messageObj.emotion.type);
            const emotionText = ai.getEmotionDescription(messageObj.emotion);
            
            messageDiv.innerHTML = `
                <div class="message-avatar">${avatar}</div>
                <div class="message-content">
                    <div class="message-bubble">
                        ${messageObj.text}
                        ${messageObj.sender === 'ai' ? `<div class="response-quality-indicator ${qualityClass}"></div>` : ''}
                    </div>
                    <div class="message-meta">
                        <div class="message-time">${messageObj.time}</div>
                        ${messageObj.sender === 'ai' ? `<div class="message-emotion">${emotionIcon} ${emotionText}</div>` : ''}
                    </div>
                </div>
            `;
            
            messagesContainer.appendChild(messageDiv);
        }

        // UIæ›´æ–°
        function updateUI() {
            const stats = ai.getStats();
            
            document.getElementById('learnedCount').textContent = stats.learnedCount;
            document.getElementById('qualityScore').textContent = stats.qualityScore + '%';
            document.getElementById('emotionState').textContent = stats.emotionState;
            document.getElementById('memoryUsage').textContent = stats.memoryUsage + '%';
            document.getElementById('personalityDisplay').textContent = stats.personality + 'ãƒ¢ãƒ¼ãƒ‰';
            
            // ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£ã‚¢ã‚¤ã‚³ãƒ³æ›´æ–°
            const personalityIcons = {
                friendly: 'ğŸ˜Š',
                curious: 'ğŸ¤”',
                thoughtful: 'ğŸ§',
                playful: 'ğŸ˜„',
                serious: 'ğŸ˜'
            };
            
            document.querySelector('.personality-icon').textContent = personalityIcons[ai.state.personality];
        }

        // æ„Ÿæƒ…ã‚¢ã‚¤ã‚³ãƒ³å–å¾—
        function getEmotionIcon(emotionType) {
            const icons = {
                positive: 'ğŸ˜Š',
                negative: 'ğŸ˜”',
                neutral: 'ğŸ˜',
                happy: 'ğŸ˜„',
                sad: 'ğŸ˜¢',
                curious: 'ğŸ¤”',
                thoughtful: 'ğŸ§'
            };
            return icons[emotionType] || 'ğŸ¤”';
        }

        // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼è¡¨ç¤º
        function showTypingIndicator() {
            const thinkingTexts = [
                'æ€è€ƒä¸­...',
                'åˆ†æä¸­...',
                'ç†è§£ä¸­...',
                'å‡¦ç†ä¸­...',
                'è€ƒãˆä¸­...'
            ];
            
            const randomText = thinkingTexts[Math.floor(Math.random() * thinkingTexts.length)];
            document.getElementById('thinkingText').textContent = randomText;
            document.getElementById('typingIndicator').style.display = 'block';
            scrollToBottom();
        }

        // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼éè¡¨ç¤º
        function hideTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'none';
        }

        // ä¸‹ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        // çµ±è¨ˆè¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleStats() {
            const stats = document.getElementById('aiStats');
            stats.classList.toggle('show');
        }

        // ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£åˆ‡ã‚Šæ›¿ãˆ
        function togglePersonality() {
            personalityIndex = (personalityIndex + 1) % personalities.length;
            ai.state.personality = personalities[personalityIndex];
            updateUI();
            
            const responses = [
                'ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£ã‚’å¤‰æ›´ã—ã¾ã—ãŸï¼',
                'æ€§æ ¼ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ã¿ã¾ã™ã­',
                'æ–°ã—ã„ãƒ¢ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã—ãŸâ™ª',
                'ã¡ã‚‡ã£ã¨é›°å›²æ°—ã‚’å¤‰ãˆã¦ã¿ã¾ã™',
                'æ°—åˆ†è»¢æ›ã—ã¦ã¿ã¾ã—ãŸ'
            ];
            
            const response = responses[Math.floor(Math.random() * responses.length)];
            setTimeout(() => addMessage(response, 'ai'), 500);
        }

        // è¨˜æ†¶å‰Šé™¤
        function clearMemory() {
            if (confirm('å­¦ç¿’ã—ãŸè¨˜æ†¶ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                ai.clearMemory();
                updateUI();
                
                const messagesContainer = document.getElementById('chatMessages');
                messagesContainer.innerHTML = `
                    <div class="message ai">
                        <div class="message-avatar">ğŸ¤–</div>
                        <div class="message-content">
                            <div class="message-bubble">
                                è¨˜æ†¶ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚æ–°ãŸãªæ°—æŒã¡ã§ä¼šè©±ã‚’å§‹ã‚ã¾ã—ã‚‡ã†ï¼
                                <div class="response-quality-indicator high"></div>
                            </div>
                            <div class="message-meta">
                                <div class="message-time">${getCurrentTime()}</div>
                                <div class="message-emotion">ğŸ˜Š å‹å¥½çš„</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›
        function exportData() {
            const data = ai.exportData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai_data_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            addMessage('å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’å‡ºåŠ›ã—ã¾ã—ãŸï¼ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚', 'ai');
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¿å­˜/èª­ã¿è¾¼ã¿
        function saveMessages() {
            try {
                localStorage.setItem('advanced_ai_messages', JSON.stringify(ai.messages));
                localStorage.setItem('advanced_ai_state', JSON.stringify({
                    personality: ai.state.personality,
                    emotion: ai.state.emotion,
                    interactionCount: ai.state.interactionCount
                }));
            } catch (e) {
                console.log('Failed to save messages:', e);
            }
        }

        function loadMessages() {
            try {
                const savedMessages = localStorage.getItem('advanced_ai_messages');
                const savedState = localStorage.getItem('advanced_ai_state');
                
                if (savedMessages) {
                    ai.messages = JSON.parse(savedMessages);
                    ai.messages.forEach(msg => displayMessage(msg));
                    scrollToBottom();
                }
                
                if (savedState) {
                    const state = JSON.parse(savedState);
                    ai.state.personality = state.personality || 'friendly';
                    ai.state.emotion = state.emotion || { type: 'neutral', intensity: 0.5 };
                    ai.state.interactionCount = state.interactionCount || 0;
                    updateUI();
                }
            } catch (e) {
                console.log('Failed to load messages:', e);
            }
        }

        // Enterã‚­ãƒ¼ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage(e);
            }
        });

        // é•·æŠ¼ã—ã§éš ã—æ©Ÿèƒ½
        let longPressTimer;
        document.querySelector('.ai-title').addEventListener('mousedown', function() {
            longPressTimer = setTimeout(() => {
                alert('ğŸš€ Claude Code Edition - Advanced AI\n\nå®Ÿè£…æ©Ÿèƒ½:\nâ€¢ é«˜åº¦ãªè‡ªç„¶è¨€èªå‡¦ç†\nâ€¢ æ„Ÿæƒ…åˆ†æã‚·ã‚¹ãƒ†ãƒ \nâ€¢ å‹•çš„ãƒ‘ãƒ¼ã‚½ãƒŠãƒªãƒ†ã‚£\nâ€¢ å­¦ç¿’ãƒ»è¨˜æ†¶æ©Ÿèƒ½\nâ€¢ ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆå¿œç­”ç”Ÿæˆ\nâ€¢ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å“è³ªè©•ä¾¡');
            }, 2000);
        });

        document.querySelector('.ai-title').addEventListener('mouseup', function() {
            clearTimeout(longPressTimer);
        });
    </script>
</body>
</html>
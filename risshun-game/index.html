<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>立春 Risshun — こちこおりをとく</title>
    <meta name="description" content="立春を題材にした小さなインタラクティブゲーム。東風解凍・黄鶯睍睆・魚上氷。" />
    <!--
    AI Model: Claude Opus 4.5
    User Prompt: risshu-gameをもっと美しくしてください
    AI Approach: Visual enhancements including starry sky, moon, crystal ice effects, water reflections, falling petals, water splashes, and atmospheric mist
    Implementation Intent: Create a more visually stunning and immersive experience while preserving the original gameplay
    -->
    <style>
      html, body { height: 100%; }
      body {
        margin: 0;
        background: #060d1a;
        color: #f3f5f7;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Yu Gothic", "Noto Sans JP", sans-serif;
        overflow: hidden;
      }
      canvas#c {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: block;
        touch-action: none;
      }
      .hud {
        position: fixed;
        top: 12px;
        left: 12px;
        background: rgba(8, 12, 20, 0.45);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 12px;
        padding: 12px 14px;
        line-height: 1.4;
        font-size: 12px;
        user-select: none;
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
      .hud b {
        font-weight: 700;
        background: linear-gradient(90deg, #ffecd2, #fcb69f);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .hud .row { opacity: 0.85; margin-bottom: 2px; }
      .banner {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        font-family: "Yu Mincho", "Hiragino Mincho ProN", "Noto Serif JP", serif;
        color: rgba(255,255,255,0.95);
        text-shadow: 0 0 30px rgba(255,200,180,0.5), 0 2px 20px rgba(0,0,0,0.4);
      }
      .banner .text {
        font-size: clamp(24px, 5vw, 72px);
        letter-spacing: 0.18em;
        transform: translateY(0) scale(0.95);
        opacity: 0;
        transition: opacity 1000ms ease, transform 1000ms cubic-bezier(0.22, 1, 0.36, 1);
      }
      .banner.show .text {
        opacity: 1;
        transform: translateY(-10px) scale(1);
      }
      .footer {
        position: fixed;
        right: 12px;
        bottom: 10px;
        background: rgba(8,12,20,0.4);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 11px;
        letter-spacing: 0.03em;
        opacity: 0.85;
        user-select: none;
        box-shadow: 0 4px 16px rgba(0,0,0,0.25);
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        margin-left: 6px;
        border-radius: 8px;
        background: rgba(255,255,255,0.06);
        font-variant-numeric: tabular-nums;
        transition: all 0.5s ease;
      }
      .badge.achieved {
        background: linear-gradient(135deg, rgba(120,200,140,0.4), rgba(100,180,160,0.3));
        box-shadow: 0 0 12px rgba(120,200,140,0.3);
      }
      @keyframes shimmer {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 1; }
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div class="hud">
      <div class="row"><b>立春</b> — 春を運ぶ東風を描いてください</div>
      <div class="row">ドラッグ/スワイプ: 風を吹かす・温める</div>
      <div class="row">クリック: 鶯を鳴かす（現れたら）</div>
    </div>
    <div class="banner" id="banner"><div class="text" id="bannerText"></div></div>
    <div class="footer">
      <span>七十二候</span>
      <span class="badge" id="badge1">東風解凍</span>
      <span class="badge" id="badge2">黄鶯睍睆</span>
      <span class="badge" id="badge3">魚上氷</span>
    </div>
    <script>
    (() => {
      'use strict';

      // Canvas setup with DPR scaling
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha: true });
      const DPR = Math.min(2, window.devicePixelRatio || 1);
      let W = 0, H = 0;

      function resize() {
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        layoutPond();
        generateStars();
      }
      window.addEventListener('resize', resize);

      // UI
      const banner = document.getElementById('banner');
      const bannerText = document.getElementById('bannerText');
      const badge1 = document.getElementById('badge1');
      const badge2 = document.getElementById('badge2');
      const badge3 = document.getElementById('badge3');
      function showBanner(text) {
        bannerText.textContent = text;
        banner.classList.add('show');
        clearTimeout(showBanner._t);
        showBanner._t = setTimeout(() => banner.classList.remove('show'), 3000);
      }

      // Input (mouse + touch)
      const pointer = { x: 0, y: 0, px: 0, py: 0, vx: 0, vy: 0, down: false, active: false };
      function updatePointerPosition(clientX, clientY) {
        pointer.px = pointer.x; pointer.py = pointer.y;
        const rect = canvas.getBoundingClientRect();
        pointer.x = (clientX - rect.left);
        pointer.y = (clientY - rect.top);
        pointer.vx = (pointer.x - pointer.px);
        pointer.vy = (pointer.y - pointer.py);
      }
      window.addEventListener('pointerdown', (e) => {
        pointer.down = true; pointer.active = true; updatePointerPosition(e.clientX, e.clientY);
        resumeAudio();
      });
      window.addEventListener('pointermove', (e) => { if (!pointer.active) return; updatePointerPosition(e.clientX, e.clientY); });
      window.addEventListener('pointerup', () => { pointer.down = false; });
      window.addEventListener('pointercancel', () => { pointer.down = false; pointer.active = false; });

      // Simple PRNG for pleasant noise
      let seed = 1337;
      function rand() { seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5; return (seed >>> 0) / 4294967296; }
      function noise2(x, y) {
        const s = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
        return s - Math.floor(s);
      }

      // Stars
      const stars = [];
      function generateStars() {
        stars.length = 0;
        const count = Math.floor((W * H) / 3000);
        for (let i = 0; i < count; i++) {
          stars.push({
            x: rand() * W,
            y: rand() * H * 0.6,
            size: 0.3 + rand() * 1.8,
            brightness: 0.3 + rand() * 0.7,
            twinkleSpeed: 0.5 + rand() * 2,
            twinkleOffset: rand() * Math.PI * 2
          });
        }
      }

      // Moon
      const moon = { x: 0, y: 0, r: 0 };
      function layoutMoon() {
        moon.r = Math.min(W, H) * 0.06;
        moon.x = W * 0.85;
        moon.y = H * 0.12;
      }

      // Ambient wind (East → West) base vector
      const EAST_WIND = { x: -0.6, y: -0.05 };

      // Wind particles
      const winds = [];
      const MAX_WIND = 600;
      function spawnWind(x, y, count, boost = 1) {
        for (let i = 0; i < count; i++) {
          if (winds.length >= MAX_WIND) break;
          const a = Math.PI * (0.15 + 0.7 * rand());
          const sp = (0.8 + rand() * 2.2) * boost;
          winds.push({
            x: x + (rand() - 0.5) * 20,
            y: y + (rand() - 0.5) * 20,
            vx: Math.cos(a) * sp + EAST_WIND.x,
            vy: Math.sin(a) * sp + EAST_WIND.y,
            life: 1 + rand() * 2.5,
            w: 0.6 + rand() * 1.8,
            hue: 185 + rand() * 50,
            luminance: 70 + rand() * 15
          });
        }
      }

      // Falling petals
      const petals = [];
      const MAX_PETALS = 80;
      function spawnPetal(x, y) {
        if (petals.length >= MAX_PETALS) return;
        petals.push({
          x: x + (rand() - 0.5) * 40,
          y: y + (rand() - 0.5) * 20,
          vx: (rand() - 0.5) * 0.8 - 0.3,
          vy: 0.3 + rand() * 0.5,
          rot: rand() * Math.PI * 2,
          rotSpeed: (rand() - 0.5) * 0.08,
          size: 3 + rand() * 4,
          life: 1,
          hue: 340 + rand() * 20
        });
      }

      // Water splashes
      const splashes = [];
      function createSplash(x, y, intensity = 1) {
        const count = Math.floor(6 + rand() * 8 * intensity);
        for (let i = 0; i < count; i++) {
          const angle = -Math.PI / 2 + (rand() - 0.5) * Math.PI * 0.8;
          const speed = (2 + rand() * 4) * intensity;
          splashes.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            size: 1 + rand() * 2
          });
        }
      }

      // Mist particles
      const mists = [];
      const MAX_MIST = 30;
      function spawnMist() {
        if (mists.length >= MAX_MIST) return;
        mists.push({
          x: rand() * W,
          y: pond.y - rand() * 80,
          vx: -0.15 - rand() * 0.2,
          size: 60 + rand() * 120,
          opacity: 0.02 + rand() * 0.04,
          life: 1
        });
      }

      // Pond & ice grid
      const pond = { x: 0, y: 0, w: 0, h: 0, r: 30 };
      let iceCols = 42, iceRows = 18;
      let ice = [];
      function layoutPond() {
        const margin = Math.max(16, Math.min(W, H) * 0.04);
        const pw = W - margin * 2;
        const ph = Math.max(140, H * 0.38);
        pond.w = pw; pond.h = ph; pond.x = margin; pond.y = H - ph - margin; pond.r = Math.min(30, Math.min(pw, ph) * 0.12);
        iceCols = Math.max(28, Math.floor(pw / 24));
        iceRows = Math.max(12, Math.floor(ph / 20));
        ice = [];
        for (let j = 0; j < iceRows; j++) {
          for (let i = 0; i < iceCols; i++) {
            const x = pond.x + (i + 0.5) * (pond.w / iceCols);
            const y = pond.y + (j + 0.5) * (pond.h / iceRows);
            const base = 0.85 + noise2(i * 0.31, j * 0.27) * 0.2 + noise2(i * 0.07, j * 0.11) * 0.1;
            ice.push({ x, y, thick: Math.min(1, base), crack: rand() * 1e6 });
          }
        }
        layoutMoon();
      }

      // Bird and blossoms
      let bird = { show: false, x: 0, y: 0, t: 0, hover: false, sang: false };
      const blossoms = [];
      function setupBlossoms() {
        blossoms.length = 0;
        const bx = W - Math.min(W * 0.22, 240);
        const by = pond.y - Math.min(120, H * 0.18);
        bird.x = bx + 24;
        bird.y = by + 24;
        const n = 14;
        for (let i = 0; i < n; i++) {
          const ang = rand() * Math.PI * 2;
          const dist = 25 + rand() * 70;
          blossoms.push({
            x: bx + Math.cos(ang) * dist + (rand() - 0.5) * 24,
            y: by + Math.sin(ang) * dist + (rand() - 0.5) * 16,
            open: 0,
            size: 0.7 + rand() * 0.5,
            rotOffset: rand() * Math.PI * 2
          });
        }
      }

      // Fish
      const fishes = [];
      function spawnFish() {
        const x = pond.x + rand() * pond.w;
        const y = pond.y + pond.h - 10 - rand() * 40;
        fishes.push({
          x, y,
          vx: (rand() * 0.7 + 0.3) * (rand() < 0.5 ? -1 : 1),
          vy: 0,
          t: rand() * 6.28,
          jumped: false,
          scale: 0.8 + rand() * 0.4,
          hue: 200 + rand() * 30
        });
        if (fishes.length > 10) fishes.shift();
      }

      // Progress and achievements
      let meltProgress = 0;
      let achieved = { kochi: false, uguisu: false, uo: false };

      // Audio (WebAudio, created on first user gesture)
      let ac = null;
      function resumeAudio() { if (!ac) { ac = new (window.AudioContext || window.webkitAudioContext)(); } }
      function envNode(duration, peak = 0.06) {
        const g = ac.createGain();
        g.gain.value = 0.0;
        const now = ac.currentTime;
        g.gain.setValueAtTime(0.0, now);
        g.gain.linearRampToValueAtTime(peak, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        g.connect(ac.destination);
        return g;
      }
      function playUguisu() {
        if (!ac) return;
        const now = ac.currentTime;

        // Create reverb for forest-like ambiance
        const convolver = ac.createConvolver();
        const reverbLength = ac.sampleRate * 1.2;
        const reverbBuffer = ac.createBuffer(2, reverbLength, ac.sampleRate);
        for (let ch = 0; ch < 2; ch++) {
          const data = reverbBuffer.getChannelData(ch);
          for (let i = 0; i < reverbLength; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (reverbLength * 0.15));
          }
        }
        convolver.buffer = reverbBuffer;

        // Mix dry and wet signals
        const dryGain = ac.createGain();
        const wetGain = ac.createGain();
        dryGain.gain.value = 0.7;
        wetGain.gain.value = 0.35;

        convolver.connect(wetGain);
        wetGain.connect(ac.destination);
        dryGain.connect(ac.destination);

        // Helper: create a note with vibrato and harmonics
        function createBirdNote(startTime, duration, freqStart, freqEnd, freqCurve, volume, vibratoRate, vibratoDepth) {
          // Main oscillator
          const osc = ac.createOscillator();
          osc.type = 'sine';

          // Frequency envelope
          osc.frequency.setValueAtTime(freqStart, now + startTime);
          if (freqCurve === 'exp') {
            osc.frequency.exponentialRampToValueAtTime(freqEnd, now + startTime + duration);
          } else if (freqCurve === 'linear') {
            osc.frequency.linearRampToValueAtTime(freqEnd, now + startTime + duration);
          } else if (Array.isArray(freqCurve)) {
            // Custom curve with multiple points
            let t = startTime;
            freqCurve.forEach(point => {
              osc.frequency.exponentialRampToValueAtTime(point.f, now + t + point.t);
              t += point.t;
            });
          }

          // Vibrato using LFO
          const vibrato = ac.createOscillator();
          const vibratoGain = ac.createGain();
          vibrato.type = 'sine';
          vibrato.frequency.value = vibratoRate;
          vibratoGain.gain.value = vibratoDepth;
          vibrato.connect(vibratoGain);
          vibratoGain.connect(osc.frequency);

          // Amplitude envelope with smooth attack and decay
          const env = ac.createGain();
          env.gain.setValueAtTime(0, now + startTime);
          env.gain.linearRampToValueAtTime(volume, now + startTime + 0.015);
          env.gain.setValueAtTime(volume, now + startTime + duration * 0.7);
          env.gain.exponentialRampToValueAtTime(0.001, now + startTime + duration);

          // Second harmonic for richness
          const osc2 = ac.createOscillator();
          osc2.type = 'sine';
          osc2.frequency.setValueAtTime(freqStart * 2, now + startTime);
          if (freqCurve === 'exp') {
            osc2.frequency.exponentialRampToValueAtTime(freqEnd * 2, now + startTime + duration);
          } else if (freqCurve === 'linear') {
            osc2.frequency.linearRampToValueAtTime(freqEnd * 2, now + startTime + duration);
          }
          vibratoGain.connect(osc2.frequency);

          const harmGain = ac.createGain();
          harmGain.gain.value = 0.15;

          // Third harmonic (subtle)
          const osc3 = ac.createOscillator();
          osc3.type = 'sine';
          osc3.frequency.setValueAtTime(freqStart * 3, now + startTime);
          if (freqCurve === 'exp') {
            osc3.frequency.exponentialRampToValueAtTime(freqEnd * 3, now + startTime + duration);
          }
          const harm3Gain = ac.createGain();
          harm3Gain.gain.value = 0.05;

          // Filter for natural bird-like tone
          const filter = ac.createBiquadFilter();
          filter.type = 'bandpass';
          filter.frequency.value = (freqStart + freqEnd) / 2;
          filter.Q.value = 2;

          // Connect main oscillator
          osc.connect(env);
          osc2.connect(harmGain);
          harmGain.connect(env);
          osc3.connect(harm3Gain);
          harm3Gain.connect(env);
          env.connect(filter);
          filter.connect(dryGain);
          filter.connect(convolver);

          // Start and stop
          vibrato.start(now + startTime);
          osc.start(now + startTime);
          osc2.start(now + startTime);
          osc3.start(now + startTime);
          vibrato.stop(now + startTime + duration + 0.1);
          osc.stop(now + startTime + duration + 0.05);
          osc2.stop(now + startTime + duration + 0.05);
          osc3.stop(now + startTime + duration + 0.05);
        }

        // "ホー" (Hoo) - Long rising note with gentle vibrato
        createBirdNote(0, 0.45, 1100, 1580, 'exp', 0.07, 5, 12);

        // Brief pause

        // "ホ" (Ho) - Short note
        createBirdNote(0.52, 0.12, 1400, 1520, 'linear', 0.065, 6, 8);

        // "ケ" (Ke) - Quick ascending note
        createBirdNote(0.66, 0.10, 1500, 1900, 'exp', 0.06, 7, 10);

        // "キョ" (Kyo) - Quick descending note
        createBirdNote(0.78, 0.15, 2200, 1400, 'exp', 0.07, 8, 12);

        // Soft echo/trailing note
        createBirdNote(0.96, 0.20, 1300, 1100, 'exp', 0.02, 4, 6);
      }
      function chime(freq = 880) {
        if (!ac) return;
        const osc = ac.createOscillator();
        const g = envNode(0.4, 0.07);
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc.connect(g);
        const now = ac.currentTime;
        osc.start(now);
        osc.stop(now + 0.4);
      }
      function playSplash() {
        if (!ac) return;
        const bufferSize = ac.sampleRate * 0.15;
        const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
        }
        const source = ac.createBufferSource();
        source.buffer = buffer;
        const filter = ac.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 1;
        const g = ac.createGain();
        g.gain.value = 0.08;
        source.connect(filter);
        filter.connect(g);
        g.connect(ac.destination);
        source.start();
      }

      // Helpers
      function inPond(x, y) {
        return x > pond.x && x < pond.x + pond.w && y > pond.y && y < pond.y + pond.h;
      }
      function meltAt(x, y, amt) {
        const rad = Math.max(20, Math.min(52, (pond.w / iceCols) * 1.5));
        const r2 = rad * rad;
        for (let k = 0; k < ice.length; k++) {
          const d2 = (ice[k].x - x) * (ice[k].x - x) + (ice[k].y - y) * (ice[k].y - y);
          if (d2 < r2) ice[k].thick = Math.max(0, ice[k].thick - amt * (1 - d2 / r2));
        }
      }

      // Draw functions
      function drawBackground(t) {
        // Deep night sky gradient
        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0, '#040810');
        g.addColorStop(0.3, '#0a1628');
        g.addColorStop(0.6, '#122040');
        g.addColorStop(1, '#1a2d4a');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);

        // Dawn glow (subtle warm light at horizon)
        const dawnG = ctx.createLinearGradient(0, H * 0.4, 0, H);
        dawnG.addColorStop(0, 'rgba(255,140,100,0)');
        dawnG.addColorStop(0.7, 'rgba(255,160,120,0.08)');
        dawnG.addColorStop(1, 'rgba(255,180,140,0.15)');
        ctx.fillStyle = dawnG;
        ctx.fillRect(0, 0, W, H);

        // Radial warm glow from right
        const rg = ctx.createRadialGradient(W * 0.82, H * 0.15, 0, W * 0.82, H * 0.15, Math.max(W, H) * 0.65);
        rg.addColorStop(0, 'rgba(255,200,160,0.2)');
        rg.addColorStop(0.3, 'rgba(255,180,140,0.08)');
        rg.addColorStop(1, 'rgba(255,180,140,0)');
        ctx.fillStyle = rg;
        ctx.fillRect(0, 0, W, H);
      }

      function drawStars(t) {
        stars.forEach(star => {
          const twinkle = 0.5 + 0.5 * Math.sin(t * star.twinkleSpeed + star.twinkleOffset);
          const alpha = star.brightness * (0.6 + twinkle * 0.4);

          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);

          const starG = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.size * 2);
          starG.addColorStop(0, `rgba(255,255,255,${alpha})`);
          starG.addColorStop(0.5, `rgba(200,220,255,${alpha * 0.5})`);
          starG.addColorStop(1, 'rgba(200,220,255,0)');
          ctx.fillStyle = starG;
          ctx.fill();
        });
      }

      function drawMoon(t) {
        const { x, y, r } = moon;

        // Moon glow
        const glowR = r * 4;
        const glowG = ctx.createRadialGradient(x, y, r * 0.5, x, y, glowR);
        glowG.addColorStop(0, 'rgba(255,250,230,0.15)');
        glowG.addColorStop(0.3, 'rgba(255,245,220,0.08)');
        glowG.addColorStop(1, 'rgba(255,240,210,0)');
        ctx.fillStyle = glowG;
        ctx.beginPath();
        ctx.arc(x, y, glowR, 0, Math.PI * 2);
        ctx.fill();

        // Crescent moon
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        const moonG = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
        moonG.addColorStop(0, 'rgba(255,252,240,0.95)');
        moonG.addColorStop(0.7, 'rgba(255,248,230,0.9)');
        moonG.addColorStop(1, 'rgba(240,235,220,0.85)');
        ctx.fillStyle = moonG;
        ctx.fill();

        // Crescent shadow
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x + r * 0.5, y - r * 0.1, r * 0.85, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.95)';
        ctx.fill();
        ctx.restore();
      }

      function drawPond(t) {
        // Water base with depth
        const g = ctx.createLinearGradient(pond.x, pond.y, pond.x, pond.y + pond.h);
        g.addColorStop(0, 'rgba(30,65,95,0.95)');
        g.addColorStop(0.5, 'rgba(25,55,80,0.97)');
        g.addColorStop(1, 'rgba(18,42,65,0.98)');
        roundRect(pond.x, pond.y, pond.w, pond.h, pond.r);
        ctx.fillStyle = g; ctx.fill();

        // Reflection of moon
        ctx.save();
        ctx.beginPath(); roundRect(pond.x, pond.y, pond.w, pond.h, pond.r); ctx.clip();

        const reflectY = pond.y + 30;
        const reflectR = moon.r * 0.6;
        const reflectX = moon.x;

        const reflectG = ctx.createRadialGradient(reflectX, reflectY, 0, reflectX, reflectY, reflectR * 3);
        reflectG.addColorStop(0, 'rgba(255,250,235,0.12)');
        reflectG.addColorStop(0.5, 'rgba(255,248,230,0.05)');
        reflectG.addColorStop(1, 'rgba(255,245,220,0)');
        ctx.fillStyle = reflectG;
        ctx.beginPath();
        ctx.ellipse(reflectX, reflectY, reflectR * 2, reflectR * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Subtle waves with shimmer
        const nWaves = 5;
        for (let i = 0; i < nWaves; i++) {
          const y = pond.y + pond.h * (0.15 + 0.18 * i) + Math.sin(t * 0.35 + i * 1.2) * 3;
          ctx.strokeStyle = `rgba(180,220,255,${0.04 + (nWaves - i) * 0.01})`;
          ctx.lineWidth = 0.8;
          ctx.beginPath();
          ctx.moveTo(pond.x, y);
          for (let x = 0; x <= pond.w; x += 8) {
            const yy = y + Math.sin((x * 0.025) + t * (0.5 + i * 0.15)) * 2.5;
            ctx.lineTo(pond.x + x, yy);
          }
          ctx.stroke();
        }
        ctx.restore();

        // Pond edge highlight
        ctx.strokeStyle = 'rgba(150,200,255,0.1)';
        ctx.lineWidth = 1.5;
        roundRect(pond.x, pond.y, pond.w, pond.h, pond.r);
        ctx.stroke();
      }

      function roundRect(x, y, w, h, r) {
        r = Math.min(r, w * 0.5, h * 0.5);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }

      function drawIce(t) {
        ctx.save();
        ctx.beginPath(); roundRect(pond.x, pond.y, pond.w, pond.h, pond.r); ctx.clip();
        const cw = pond.w / iceCols, ch = pond.h / iceRows;

        for (let j = 0; j < iceRows; j++) {
          for (let i = 0; i < iceCols; i++) {
            const k = j * iceCols + i;
            const cell = ice[k];
            if (cell.thick <= 0.02) continue;

            const ix = pond.x + i * cw;
            const iy = pond.y + j * ch;
            const alpha = Math.min(0.95, 0.2 + cell.thick * 0.8);

            // Ice crystal base with gradient
            const iceG = ctx.createLinearGradient(ix, iy, ix + cw, iy + ch);
            iceG.addColorStop(0, `rgba(200,235,255,${0.12 * cell.thick})`);
            iceG.addColorStop(0.5, `rgba(180,220,250,${0.15 * cell.thick})`);
            iceG.addColorStop(1, `rgba(160,210,245,${0.1 * cell.thick})`);
            ctx.fillStyle = iceG;
            ctx.fillRect(ix, iy, cw + 1, ch + 1);

            // Crystal patterns
            if (cell.thick > 0.3) {
              ctx.strokeStyle = `rgba(220,245,255,${0.2 * cell.thick})`;
              ctx.lineWidth = 0.5;

              // Frost crystal lines
              const cx = ix + cw / 2;
              const cy = iy + ch / 2;
              const numLines = 3;
              for (let l = 0; l < numLines; l++) {
                const angle = (l / numLines) * Math.PI + noise2(i * 0.5, j * 0.5 + t * 0.01) * 0.3;
                const len = (cw * 0.4) * cell.thick;
                ctx.beginPath();
                ctx.moveTo(cx - Math.cos(angle) * len, cy - Math.sin(angle) * len);
                ctx.lineTo(cx + Math.cos(angle) * len, cy + Math.sin(angle) * len);
                ctx.stroke();
              }
            }

            // Surface shimmer
            const shimmer = 0.5 + 0.5 * Math.sin(t * 0.5 + i * 0.3 + j * 0.4);
            ctx.fillStyle = `rgba(255,255,255,${alpha * 0.08 * shimmer})`;
            ctx.fillRect(ix, iy, cw, ch);

            // Edge highlights
            ctx.strokeStyle = `rgba(200,230,255,${0.15 * cell.thick})`;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(ix, iy + ch * 0.5 + (noise2(i, j) - 0.5) * 4);
            ctx.lineTo(ix + cw, iy + ch * 0.5 - (noise2(i + 1, j) - 0.5) * 4);
            ctx.stroke();
          }
        }
        ctx.restore();
      }

      function drawWinds(t, dt) {
        ctx.lineCap = 'round';
        for (let i = winds.length - 1; i >= 0; i--) {
          const p = winds[i];
          const curl = Math.sin((p.y + t * 40) * 0.02) * 0.08;
          p.vy += curl * 0.05;
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.008;

          if (pointer.down) {
            const dx = p.x - pointer.x, dy = p.y - pointer.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < 100*100) {
              p.vx += pointer.vx * 0.012; p.vy += pointer.vy * 0.012;
              meltAt(p.x, p.y, 0.0025);
            }
          }

          const warm = (p.x - pond.x) / pond.w;
          if (inPond(p.x, p.y)) meltAt(p.x, p.y, 0.0005 + warm * 0.0008);

          // Draw wind trail with glow
          const alpha = Math.max(0, p.life) * 0.4;
          ctx.strokeStyle = `hsla(${p.hue}, 75%, ${p.luminance}%, ${alpha})`;
          ctx.lineWidth = p.w;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x - p.vx * 3, p.y - p.vy * 3);
          ctx.stroke();

          // Subtle glow
          if (p.life > 0.5) {
            ctx.strokeStyle = `hsla(${p.hue}, 60%, 85%, ${alpha * 0.3})`;
            ctx.lineWidth = p.w * 2.5;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x - p.vx * 2, p.y - p.vy * 2);
            ctx.stroke();
          }

          if (p.life <= 0 || p.x < -50 || p.y < -50 || p.x > W + 50 || p.y > H + 50) {
            winds.splice(i, 1);
          }
        }

        if (winds.length < MAX_WIND - 50) {
          const y = pond.y + pond.h * (0.1 + 0.8 * rand());
          spawnWind(W + 10, y, 8, 1);
        }

        if (pointer.active && (Math.abs(pointer.vx) + Math.abs(pointer.vy)) > 1) {
          spawnWind(pointer.x, pointer.y, 12, 1.5);
        }
      }

      function drawPetals(dt) {
        for (let i = petals.length - 1; i >= 0; i--) {
          const p = petals[i];

          // Wind influence
          p.vx += EAST_WIND.x * 0.02;
          p.vy += 0.01;
          p.x += p.vx;
          p.y += p.vy;
          p.rot += p.rotSpeed;
          p.life -= 0.004;

          // Gentle flutter
          p.vx += Math.sin(time * 2 + i) * 0.02;
          p.vy += Math.cos(time * 1.5 + i) * 0.01;

          if (p.life <= 0 || p.y > H + 20) {
            petals.splice(i, 1);
            continue;
          }

          // Draw petal
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.scale(p.size / 4, p.size / 4);

          const petalG = ctx.createRadialGradient(0, 0, 0, 0, 0, 4);
          petalG.addColorStop(0, `hsla(${p.hue}, 80%, 92%, ${p.life * 0.9})`);
          petalG.addColorStop(1, `hsla(${p.hue}, 70%, 85%, ${p.life * 0.6})`);
          ctx.fillStyle = petalG;

          ctx.beginPath();
          ctx.ellipse(0, 0, 4, 2.5, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      function drawSplashes(dt) {
        for (let i = splashes.length - 1; i >= 0; i--) {
          const s = splashes[i];
          s.vy += 0.15;
          s.x += s.vx;
          s.y += s.vy;
          s.life -= 0.03;

          if (s.life <= 0 || s.y > pond.y + pond.h) {
            splashes.splice(i, 1);
            continue;
          }

          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size * s.life, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(200,235,255,${s.life * 0.7})`;
          ctx.fill();
        }
      }

      function drawMist(t) {
        mists.forEach((m, i) => {
          m.x += m.vx;
          if (m.x + m.size < 0) {
            m.x = W + m.size;
            m.y = pond.y - rand() * 80;
          }

          const mistG = ctx.createRadialGradient(m.x, m.y, 0, m.x, m.y, m.size);
          mistG.addColorStop(0, `rgba(200,220,240,${m.opacity * (0.8 + 0.2 * Math.sin(t * 0.3 + i))})`);
          mistG.addColorStop(0.5, `rgba(180,210,235,${m.opacity * 0.5})`);
          mistG.addColorStop(1, 'rgba(180,210,235,0)');
          ctx.fillStyle = mistG;
          ctx.beginPath();
          ctx.ellipse(m.x, m.y, m.size, m.size * 0.4, 0, 0, Math.PI * 2);
          ctx.fill();
        });

        if (mists.length < MAX_MIST && rand() < 0.02) {
          spawnMist();
        }
      }

      function drawBlossoms(t, dt) {
        const targetOpen = Math.min(1, Math.max(0, (meltProgress - 0.3) * 2.2));
        blossoms.forEach(b => { b.open += (targetOpen - b.open) * 0.015; });

        // Branch with more detail
        const bx = W - Math.min(W * 0.22, 240);
        const by = pond.y - Math.min(120, H * 0.18);

        // Main branch
        ctx.strokeStyle = 'rgba(90,70,55,0.9)';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(bx - 60, by + 70);
        ctx.quadraticCurveTo(bx - 20, by + 45, bx + 50, by + 15);
        ctx.stroke();

        // Branch highlight
        ctx.strokeStyle = 'rgba(120,100,80,0.4)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(bx - 55, by + 65);
        ctx.quadraticCurveTo(bx - 15, by + 42, bx + 45, by + 12);
        ctx.stroke();

        // Smaller branches
        ctx.strokeStyle = 'rgba(100,80,65,0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(bx, by + 40);
        ctx.quadraticCurveTo(bx + 20, by + 30, bx + 35, by + 45);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bx - 30, by + 55);
        ctx.quadraticCurveTo(bx - 20, by + 45, bx - 10, by + 55);
        ctx.stroke();

        // Blossoms
        blossoms.forEach((b, i) => {
          const s = (0.5 + b.open * 0.7) * b.size;
          if (s > 0.3) {
            drawPlum(b.x, b.y, s, t + b.rotOffset);

            // Spawn petals when wind is strong and flowers are open
            if (b.open > 0.7 && pointer.down && rand() < 0.03) {
              spawnPetal(b.x, b.y);
            }
          }
        });
      }

      function drawPlum(x, y, s, t) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(s, s);
        ctx.rotate(Math.sin(t * 0.5) * 0.05);

        // Petals
        for (let i = 0; i < 5; i++) {
          const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
          const px = Math.cos(a) * 9, py = Math.sin(a) * 9;
          const r = 10;

          // Petal shadow
          ctx.fillStyle = 'rgba(200,150,170,0.3)';
          ctx.beginPath();
          ctx.arc(px + 1, py + 1, r, 0, Math.PI * 2);
          ctx.fill();

          // Petal gradient
          const g = ctx.createRadialGradient(px - 3, py - 3, 0, px, py, r);
          g.addColorStop(0, 'rgba(255,245,250,0.98)');
          g.addColorStop(0.4, 'rgba(255,220,235,0.95)');
          g.addColorStop(0.8, 'rgba(255,180,205,0.9)');
          g.addColorStop(1, 'rgba(255,160,190,0.85)');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(px, py, r, 0, Math.PI * 2);
          ctx.fill();

          // Petal highlight
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.beginPath();
          ctx.arc(px - 2, py - 2, r * 0.3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Center
        const centerG = ctx.createRadialGradient(0, 0, 0, 0, 0, 6);
        centerG.addColorStop(0, 'rgba(255,240,200,1)');
        centerG.addColorStop(0.5, 'rgba(255,220,180,0.95)');
        centerG.addColorStop(1, 'rgba(255,200,160,0.9)');
        ctx.fillStyle = centerG;
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 2);
        ctx.fill();

        // Stamens
        ctx.strokeStyle = 'rgba(180,100,80,0.7)';
        ctx.lineWidth = 0.8;
        for (let i = 0; i < 8; i++) {
          const a = (i / 8) * Math.PI * 2;
          const len = 4 + rand() * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(a) * len, Math.sin(a) * len);
          ctx.stroke();

          // Anther
          ctx.fillStyle = 'rgba(200,150,100,0.9)';
          ctx.beginPath();
          ctx.arc(Math.cos(a) * len, Math.sin(a) * len, 0.8, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }

      function drawBird(t) {
        if (!bird.show) return;
        bird.t += 0.016;
        const flap = Math.sin(bird.t * 3.5) * 2;
        const x = bird.x, y = bird.y + Math.sin(time * 1.8) * 1.5;

        bird.hover = (Math.hypot(pointer.x - x, pointer.y - y) < 28);

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1.15, 1.15);

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.beginPath();
        ctx.ellipse(2, 8, 16, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Body gradient
        const bodyG = ctx.createLinearGradient(-15, -10, 15, 10);
        if (bird.hover) {
          bodyG.addColorStop(0, 'rgba(180,210,160,0.98)');
          bodyG.addColorStop(0.5, 'rgba(160,195,140,0.95)');
          bodyG.addColorStop(1, 'rgba(140,180,120,0.92)');
        } else {
          bodyG.addColorStop(0, 'rgba(170,200,150,0.95)');
          bodyG.addColorStop(0.5, 'rgba(150,185,130,0.92)');
          bodyG.addColorStop(1, 'rgba(130,170,110,0.9)');
        }
        ctx.fillStyle = bodyG;
        ctx.strokeStyle = 'rgba(60,80,50,0.4)';
        ctx.lineWidth = 1;

        // Body shape
        ctx.beginPath();
        ctx.moveTo(-18, 4);
        ctx.quadraticCurveTo(-5, -14 + flap, 18, 0);
        ctx.quadraticCurveTo(8, 12, -18, 4);
        ctx.fill();
        ctx.stroke();

        // Wing
        ctx.fillStyle = 'rgba(140,175,120,0.8)';
        ctx.beginPath();
        ctx.moveTo(-5, 0);
        ctx.quadraticCurveTo(0, -8 + flap * 0.5, 10, -2);
        ctx.quadraticCurveTo(5, 4, -5, 0);
        ctx.fill();

        // Tail
        ctx.fillStyle = 'rgba(130,165,110,0.85)';
        ctx.beginPath();
        ctx.moveTo(-18, 4);
        ctx.lineTo(-26, 2);
        ctx.lineTo(-24, 6);
        ctx.closePath();
        ctx.fill();

        // Beak
        const beakG = ctx.createLinearGradient(18, 0, 28, 4);
        beakG.addColorStop(0, 'rgba(255,220,140,0.95)');
        beakG.addColorStop(1, 'rgba(240,190,100,0.9)');
        ctx.fillStyle = beakG;
        ctx.beginPath();
        ctx.moveTo(18, 0);
        ctx.lineTo(28, 2);
        ctx.lineTo(18, 5);
        ctx.closePath();
        ctx.fill();

        // Eye
        ctx.fillStyle = 'rgba(20,30,20,0.95)';
        ctx.beginPath();
        ctx.arc(10, -1, 2, 0, Math.PI * 2);
        ctx.fill();

        // Eye highlight
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.beginPath();
        ctx.arc(10.5, -1.5, 0.6, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Glow when hovering
        if (bird.hover) {
          const glowG = ctx.createRadialGradient(x, y, 0, x, y, 40);
          glowG.addColorStop(0, 'rgba(200,255,180,0.15)');
          glowG.addColorStop(1, 'rgba(200,255,180,0)');
          ctx.fillStyle = glowG;
          ctx.beginPath();
          ctx.arc(x, y, 40, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      canvas.addEventListener('click', () => {
        if (bird.show && Math.hypot(pointer.x - bird.x, pointer.y - bird.y) < 32) {
          playUguisu();
          if (!achieved.uguisu) {
            achieved.uguisu = true;
            badge2.classList.add('achieved');
            showBanner('黄鶯睍睆');
          }
          bird.sang = true;
        }
      });

      function drawFishes(dt) {
        ctx.save();
        ctx.beginPath();
        roundRect(pond.x, pond.y, pond.w, pond.h, pond.r);
        ctx.clip();

        for (let i = fishes.length - 1; i >= 0; i--) {
          const f = fishes[i];
          f.t += dt * (0.8 + rand() * 0.2);
          f.x += f.vx;
          f.y += Math.sin(f.t) * 0.5 + f.vy;
          f.vx *= 0.996; f.vy *= 0.99;

          if (pointer.down) {
            const dx = f.x - pointer.x, dy = f.y - pointer.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < 100*100) { f.vy -= 0.06; }
          }

          const cell = pickCellAt(f.x, pond.y + 2);
          const surfaceOpen = cell ? (1 - cell.thick) : 0;
          if (surfaceOpen > 0.55 && f.y < pond.y + 8 && !f.jumped) {
            f.vy = -2.8 - rand() * 1.5;
            f.jumped = true;
            chime(700 + rand() * 200);
            playSplash();
            createSplash(f.x, pond.y + 5, 1.2);
            if (!achieved.uo) {
              achieved.uo = true;
              badge3.classList.add('achieved');
              showBanner('魚上氷');
            }
          }
          if (f.y > pond.y + pond.h - 8) { f.y = pond.y + pond.h - 8; f.vy *= -0.4; f.jumped = false; }
          if (f.x < pond.x + 10) { f.x = pond.x + 10; f.vx *= -0.8; }
          if (f.x > pond.x + pond.w - 10) { f.x = pond.x + pond.w - 10; f.vx *= -0.8; }

          // Draw fish
          ctx.save();
          ctx.translate(f.x, f.y);
          ctx.scale(f.scale * (f.vx > 0 ? -1 : 1), f.scale);

          // Body gradient
          const fishG = ctx.createLinearGradient(-10, -6, 10, 6);
          fishG.addColorStop(0, `hsla(${f.hue}, 60%, 80%, 0.9)`);
          fishG.addColorStop(0.5, `hsla(${f.hue}, 50%, 85%, 0.85)`);
          fishG.addColorStop(1, `hsla(${f.hue}, 40%, 75%, 0.8)`);
          ctx.fillStyle = fishG;
          ctx.strokeStyle = `hsla(${f.hue}, 50%, 70%, 0.5)`;
          ctx.lineWidth = 1;

          // Body
          ctx.beginPath();
          ctx.moveTo(-10, 0);
          ctx.quadraticCurveTo(0, -7, 10, 0);
          ctx.quadraticCurveTo(0, 7, -10, 0);
          ctx.fill();
          ctx.stroke();

          // Tail
          ctx.fillStyle = `hsla(${f.hue}, 55%, 78%, 0.85)`;
          ctx.beginPath();
          ctx.moveTo(-10, 0);
          ctx.lineTo(-18, -5 + Math.sin(f.t * 2) * 2);
          ctx.lineTo(-16, 0);
          ctx.lineTo(-18, 5 + Math.sin(f.t * 2) * 2);
          ctx.closePath();
          ctx.fill();

          // Fin
          ctx.beginPath();
          ctx.moveTo(0, -4);
          ctx.quadraticCurveTo(2, -8, 5, -5);
          ctx.lineTo(0, -4);
          ctx.fill();

          // Eye
          ctx.fillStyle = 'rgba(30,50,60,0.9)';
          ctx.beginPath();
          ctx.arc(6, -1, 1.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
        ctx.restore();
      }

      function pickCellAt(x, y) {
        if (!inPond(x, y)) return null;
        const i = Math.floor((x - pond.x) / (pond.w / iceCols));
        const j = Math.floor((y - pond.y) / (pond.h / iceRows));
        const idx = j * iceCols + i;
        return ice[idx];
      }

      // Main loop
      let last = 0, time = 0;
      function loop(ts) {
        if (!last) last = ts;
        const dt = Math.min(33, ts - last) / 16.666;
        last = ts;
        time += dt * 0.016 * 60;

        drawBackground(time);
        drawStars(time);
        drawMoon(time);
        drawMist(time);
        drawPond(time);
        drawFishes(dt);
        drawIce(time);
        drawSplashes(dt);
        drawWinds(time, dt);
        drawPetals(dt);
        drawBlossoms(time, dt);
        drawBird(time);

        // Compute melt progress
        let sum = 0;
        for (let k = 0; k < ice.length; k++) sum += (1 - ice[k].thick);
        const next = sum / ice.length;
        meltProgress += (next - meltProgress) * 0.04;

        if (!achieved.kochi && meltProgress > 0.18) {
          achieved.kochi = true;
          badge1.classList.add('achieved');
          showBanner('東風解凍');
        }

        if (!bird.show && meltProgress > 0.45) { bird.show = true; }
        if (meltProgress > 0.5 && rand() < 0.025) spawnFish();

        if (achieved.kochi && achieved.uguisu && achieved.uo) {
          if (!loop.done) {
            loop.done = true;
            setTimeout(() => showBanner('立春'), 500);
          }
        }

        requestAnimationFrame(loop);
      }

      // Init
      resize();
      layoutPond();
      setupBlossoms();
      generateStars();

      // Seed wind
      for (let i = 0; i < 200; i++) spawnWind(W * (0.6 + 0.4 * rand()), pond.y + rand() * pond.h, 1, 1);

      // Seed mist
      for (let i = 0; i < 10; i++) spawnMist();

      requestAnimationFrame(loop);
    })();
    </script>
  </body>
</html>
